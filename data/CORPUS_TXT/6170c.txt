<heading>Part 1: Communication and synchronisation mechanisms and formal method definition</heading><heading>Semaphores, monitors and message passing</heading><heading>Semaphores</heading>Semaphore is an abstract data type invented by a Dutch computer scientist E.W. Dijkstra in middle 1960's. It was first introduced and successfully implemented to protect critical sections. Semaphore is a shared, nonnegative integer variable which can be manipulated exclusively by only two operations: <list>P(s) for wait (Dutch word Passeren)V(s) for signal (Dutch word Vrygeven)</list>Both operations are indivisible - it means they are executed as atomic actions. The third operation on semaphore is its initialisation "init". There are two approaches in using the semaphores for synchronisation: <list>Binary semaphores - can have only two values: 0 and 1Counting semaphores - can have any nonnegative values.</list><heading>How the semaphore works</heading>The current value of the semaphore represents the number of free resource units that can be used at this time. The binary semaphores are used in cases, where there is only one unit which can be either available or not available. For plural number of units the counting semaphores are implemented. If the semaphore value is positive it means that there are available resources and that they can be used. Each resource unit occupation results in decrementing the semaphore value. If the semaphore value is 0 it means that all resources are currently being used and the process must wait until the resources are available again. <heading>Operations on semaphores</heading>In order to decrease the value of the semaphore we use P(s) operation. This operation decrements the value of s as long as s>0:  FORMULA   FORMULA  the process is put to wait until s is positive so that the process may proceed again In order to increase the value of the semaphore we use V(s) operation. If s was equal to 0 and there are any processes waiting, one process will be then awaken and able to proceed. In other case s is atomically increased by one. The "init" operation is performed only once for a single semaphore before any semaphore requests are made e.g.  FORMULA  <heading>Examples of usage</heading>The most common semaphore is a binary semaphore used for Mutual Exclusion. It controls the access to a single resource used by two or more different processes. Its aim is to assure that only one process at a time can access the resource. This kind of semaphore is typically initialized with value 1. It is decreased to 0 each time a process accesses the resource and then increased to one each time the resource is freed. We can also use semaphores when we want to make sure that one section of the code is run before another section executed by completely different process. <heading>Disadvantages</heading>Semaphores are relatively difficult in implementation. It is very easy to make mistakes such as forgetting the signal operation V(s), especially when several semaphores are used. Due to lack of relationship between the operation name and mnemonic used for its description it is also very easy to mix up wait(s) - P(s) and signal(s) - V(s). <heading>Monitors</heading>Monitor is a structure invented by a Danish computer scientist Per Brinch Hansen in 1972. Monitors are implemented to assure synchronization of different processes that use some shared resource. They were introduced as a more structured approach than semaphores. They can be found in many concurrent languages e.g. Java. The monitors became very popular as they provide a very simple and safe way in which the programmer can obtain mutual exclusion (Axford 1987). <heading>Monitor structure</heading>The monitor consists of: <list>The shared variables associated with the resourceA set of procedures which can operate on the shared variables</list> FORMULA  <heading>How the monitor works</heading>The key point of monitor approach to synchronization is that only monitor's procedures can access the shared variables. Only one process can run monitor's procedure at a time. It guarantees the mutual exclusion. If one process is running the monitor's procedure, no other process can run any procedure of this monitor until the first one finishes and leaves the monitor. It makes the use of shared variables easier for programmers - they do not need to assure the exclusive use of shared resources, it is enough to place them inside the monitor which will automatically take care for that. In case when a process wants to run monitor's procedure which is currently used by another process, its request is put on queue. <heading>Condition variables</heading>Monitors also have condition variables, on which a process can wait if conditions are not right for it to continue executing in the monitor. Some other process can then get in the monitor and perhaps change the state of the monitor. If conditions are now right, that process can signal a waiting process, moving the latter to the ready queue to get back into the monitor when it becomes free (Hartley 1997). <heading>Operations on condition variables</heading>We can perform the following operations on condition variables: <list>wait(c) - it results in adding the calling process to the queue. It releases the monitor what means that other processes can now access it. signal(c) - it removes the head process from the queue. In case the queue is empty it does not cause any result. The awaken process resumes execution of instruction following after wait(c). signal_all(c) - (sometimes referred to as broadcast signal) it removes all processes from the queue. It has no effect if the queue is empty.empty(c) - it is a logical function. It returns true in case there are no processes in the queue. </list>Even though wait(c) and signal(c) look similar to P(s) and V(s) there are crucial differences between them (Andrews 1991): <list>signal(c) gives no results in case the queue is empty (whereas the semaphore would be increased)wait(c) always delays the process until signal(c) is executed (whereas P(s) delays the process only if s=0)</list><heading>Message passing</heading>So far I have described solutions which can be used only in a shared memory environment. Nowadays, when network architectures are becoming more and more popular, a new solution needed to be introduced. This is where the message passing evolved. Sometimes it might be also convenient that processes executing on the shared memory architecture use the message passing as communication and synchronisation mechanism instead of using the shared variables. It happens e.g. when processes are executing on behalf of different users (Andrews 1991:339). <heading>Message passing operations</heading>The primitives operations for message passing mechanism are: <list>send (destination, message)receive (source, message)</list><heading>How the message passing works</heading>In case of message passing mechanism processes share channels. To initiate communication one process sends a message to a channel; another process acquires the message by receiving it from the channel (Andrews 1991:339). <heading>Message passing models</heading>There are three message passing models: <list>synchronousasynchronousbuffered </list>In asynchronous message passing, channels are unbounded queues of messages. Execution of each send statement attaches a message to a queue. As the channels are supposed to be unbounded the sender is not delayed. To receive the message the process executes receive statement. If the channel is empty the receiver is delayed. Using the asynchronous message passing model has three major disadvantages: <list>We can get the situation in which the receiver is far behind the sender. The sending process does not known about any failures that can occur during transmission.There is a need to buffer the messages. It is obvious that buffers are not infinite therefore in case of sending too many messages the programme can either crash or send will be blocked.</list>In synchronous message passing we can avoid these problems. In this model both send and receive statement are blocking primitives. The communication is performed synchronously that means that the sender blocks until the receiver does a receive and the receiver blocks until the sender does a send. In buffered message passing the channel has a fixed capacity. In case the channel is full the sender is delayed. If the channel is empty the receiver is delayed. <heading>The significance of Formal Methods in designing safety critical Real Time & Concurrent software systems</heading>While designing new software, the main goal for the software engineer is to ensure that his product is reliable and predictable. Therefore he must make sure that all design flaws are eliminated. Unfortunately the more complex the system is, the more difficult it is to ensure its correct performance. There are three main approaches in handling the design flaws: <list>testingdesign diversityfault avoidance</list>Several researches have shown that the fault avoidance approach is the best one to use for high integrity systems. Formal Methods are the most rigorous of all fault avoidance approaches and therefore they are most hopeful. Using the computers for monitoring and controlling safety critical system is a convenient solution on one hand, but very dangerous on the other. Making a computer system responsible for controlling planes, medical devices or nuclear power plant puts our life in risk. Even a single bug can be considerably hazardous. Therefore the Formal Methods - as most promising - should be used in all applications where even a single error can be critical to the system or worse - to our life. The software engineers must never forget that their products control several systems that influence our life: trains, planes, medical equipment. Formal Methods are mathematical techniques and tools used for: <list>specificationdesignverification </list>of software and hardware systems (Butler 2001). The aim of formalization is to decrease the risk of severe specification and design errors. Even though the use of Formal Methods is relatively difficult and expensive, it also gives numerous benefits. The Formal Methods enable verifying system correctness by mathematical methods, which is a much more reliable approach than system testing. Thanks to using Formal Methods <list>the defects can be found earlier and therefore its correction is easier and less expensivecertain properties of the system can be checked automaticallythe rework is decreased </list>Without use of Formal Methods the requirements are written in informal manner. Such approach can be very risky as the specification is then: <list>too general - it does not precise how to satisfy the requirementsnot accurate enough - different people can interpret it differently</list>A way to avoid these problems is to employ Formal Methods. Formal Methods are very specific; they make designers think about the problem more thoroughly as they are supposed to describe the problem in precise formal language. Specification expressed in mathematical notations is a very accurate description of desirable behaviour. It has been proved that formalisation improves system quality, consistency and integrity. There are many different Formal Methods to choose from: <list>Abstract State MachinesB-MethodCommUnityLotosPetri NetsSDLTRIOVDMZ</list>Once it is decided to use Formal Methods for the project, we need to think which one to use. <heading>Part 2: Real-time application</heading><heading>A detailed explanation of the application</heading><heading>GREENHOUSE SYSTEM</heading>The real-time application that I am going to describe is the Greenhouse System. As greenhouse is supposed to provide "weather conditions" suitable for cultivating plants there is a strong need to monitor and control these conditions. Therefore the real-time system will be designed. This system will be used to monitor and control the current conditions inside the greenhouse. It analyses (Analyser) information provided by sensors (Sensor Monitor) and based on it decides what action should be taken (Decision System). The actions are taken if data is incorrect (conditions are different from desired). In case of major variances between current and desired conditions the failure will be detected (Check for Failure) and the alarm will be activated (Activate Alarm). All sensors of each type provide information simultaneously and the system must respond within given time limits. The Greenhouse System is an example of a soft real-time system. It means that any time delay does not cause any critical error but only decreases the quality of the service. It is not that critical for the greenhouse if e.g. the temperature is a little bit too low for while and that the heating will be turned on a minute later. Therefore it is assumed that the sensors will be read every 5 minutes and that the system should analyse the data and take suitable actions within 3 minutes. The following processes will be monitored and controlled in the Greenhouse System: <list>Temperature-sensor monitor - checks the temperatures and sends the data from all sensors to the temperature analyserHumidity-sensor monitor - checks the humidity and sends the data from all sensors to humidity analyserCO 2 - sensor monitor - checks the level of CO 2 and sends the data from all sensors to CO 2 analyserLight-exposure sensor monitor - checks the light exposure and sends the data from all sensors to light analyserTemperature Analyser - collects information from temperature monitor. It compares the reading from each sensor with the expected value and sends the difference to Heating/Cooling Decision SystemHumidity Analyser - collects information from humidity monitor. It compares the reading from each sensor with the expected value and sends the difference to Humidifying/Drying Decision SystemCO 2 Analyser - collects information from CO 2 monitor. It compares the reading from each sensor with the expected value and sends the difference to Air Exchange Decision SystemLight Analyser - collects information from light monitor. . It compares the reading from each sensor with the expected value and sends the difference to Change Light Exposure Decision SystemTime Analyser checks the current time and compares it with time set by administrator for activating irrigation and sends the data Irrigation Decision SystemHeating/Cooling Decision System - receives data from Temperature Analyser and based on it decides whether to activate radiators or notHumidifying/Drying Decision System - receives data from Humidity Analyser and based on it decides whether to activate humidifier or notChange light exposure Decision System - receives data from Light Analyser and based on it decides whether to change the light exposure or notAir exchange Decision System - receives data from CO 2 Analyser and based on it decides whether to exchange air or notIrrigation Decision System - receives data from Time Analyser and based on it decides whether to activate irrigation or notCheck for failure - this process checks if there are any failures e.g. data collected from at least one of sensors placed all around the greenhouse is totally different from expected. The highest acceptable variance between current and desired parameters is set by the user. If the failure occurs the alarm is activated and the failure is reportedReport - all data collected from the sensors and analysed and are placed in the report automatically. Also the user can have access to the data. Activate alarm - this process informs the greenhouse owner/administrator that the failure has occurred by turning on the alarm.</list>The system contains the user console so that the system administrator can define: <list>desired temperatures Tempdesired humidity Humdesired level of CO 2 Levdesired light exposure Lighttimes when the irrigation system is activated Timethe highest acceptable variances between current and desired temperatures ΔTemphumidity ΔHumlevel of CO 2 ΔLevlight exposure ΔLight</list>If the variance is higher than acceptable the alarm will be activated Administrator can also request the report data. <heading>The exemplary scenario 1 (a failure detected)</heading><list>The desired data parameters are set with the user console e.g.:Temp Hum Light LevTime (when the irrigation is activated) ΔTempΔHumΔLightΔ CO 2 Monitors read the sensorsCurrent parameters from Monitors and the clock are sent to Analysers Analyse the dataDifference between expected and current temperature is bigger than acceptable Δtemp > ΔTemp - failure detectedActivate alarm and report data</list><heading>The exemplary scenario 2 (no failure detected, but the temperature too low)</heading><list>The desired data parameters are set with the user console:Temp Hum Light Lev Time (when the irrigation is activated) ΔTempΔHumΔLightΔLev Monitors read the sensorsCurrent parameters from Monitors and the clock are sent to Analysers Analyse the data by comparison: the temperatures: desired - Temp and current - tempthe humidity: desired - Hum and current - humthe light exposure: desired - Light and current - lightthe CO 2 level: desired - Lev and current - levcurrent time with the administrator settings Time for irrigation systemThe results are:Temp > temp Hum = humLight = lightLev = levTime ≠ time - no need to activate the irrigation systemSend the following data to Report, Decision System and Check for FailureΔtemp = Temp - temp = 2° CΔhum = 0 Δlight = 0Δlev = 0 Time ≠ timeCheck for failure:Δtemp < ΔTemp - no failureΔhum < ΔHum - no failureΔlight < ΔLight - no failureΔlev < ΔLev - no failureThe Decision System orders:to activate heating due to the temperature differencenot to activate humidifiersnot to activate air exchangenot to change the light exposurenot to activate irrigation systemMonitors read the sensors...</list><heading>Data flow diagram, inputs and outputs</heading>Figure 1 shows the general Data Flow Diagram of the whole system: <list>The administrator sets the desired parametersSensor Monitors and a clock provide the current parameters inside the greenhouse to Data AnalyserData Analyser compares the actual data with desired ones.The compared data are sent to Decision System, Check for Failure and are added to ReportDecision System is responsible for activating heating/cooling, humidifying/drying, air exchange, changing light exposure and activating irrigationThe analysed data are checked for major variances (Check for Failure) and in case they appear the alarm is activatedAll data from Check for Failure and Data Analyser are written in the report.</list><figure/>"Sensor monitor" is a generic name for the whole set of processes shown at Figure 2: <figure/>"Data analyser" is a generic name for the whole set of processes shown at Figure 3: <figure/>"Decision System" is a generic name for the whole set of processes shown at Figure4: <figure/>In the following table I will show inputs and outputs of all processes: <table/><heading>Part 3: Definition of concurrent processes and synchronisation mechanism. </heading><heading>Concurrent processes definition. Communication and synchronization mechanisms</heading>In the Greenhouse System there are many concurrent processes. In fact all of them (excluding Activate Alarm) are running simultaneously. All the processes contained in Sensor Monitor are executed at the same time (e.g. every 5 minutes). Than all processes gathered in Data Analyser analyse the data at the same time. Another set of concurrent processes is grouped within Decision System. In this part of the coursework I will write a programme using SR language to show how the processes communicate and synchronise their access to shared variables. In order to provide mutual exclusion semaphores will be implemented. I choose the following processes: <list>Analyse Current TemperatureChange Desired Conditions Reading Report</list>This process is similar to all the processes from its group and all of them would be implemented in the same way. This process has access to the following shared data: desired temperature which is set in Change Desired Conditions process Report which can be read by the system administrator. In this case temperature is the only desired parameter that is changed. In the same way we can change all the desired parameters (each parameter must have its own semaphore). Temperature is of course the shared data. The administrator can read the report which is also a shared resource. To implement these processes I need to use two semaphores: <list>One for desired temperature - two processes have access to this variable: Change Desired Condition and Analyse Current Temperature. While the desired temperature is being changed it cannot be accessed for comparison purposes. One for Report - two processes have access to this variable: Analyse Current Temperature and Reading Report. While the data are added to the report it cannot be read by the administrator. </list><heading>SR code</heading>The programme in SR:  FORMULA  A part of output from the programme:  FORMULA  