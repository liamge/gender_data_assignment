<heading>Defining the problem</heading><heading>Enter product details:</heading>As the title indicates it, the program is to be an orders placement program. In this case, the user will have 3 products to choose from during the orders placement process. These products details will be recorded into the program by the user at the start of the program. He will have to enter these details for each of the three products: <list>Product NameProduct ID (in the range 1000 - 1999)Product Cost (in pence)Number of Products in Stock</list><heading>Placing order(s):</heading>The program should then ask the user if he wants to place an order. If answer is 'y' or 'Y', the program should use a loop to offer the user the opportunity to keep adding products to the order until he enters 'n'. The user can keep adding products to the order until they say that they do not want to add anymore (by entering 'n' when asked) at which point the program will tell the user the cost of the whole order. To add a product to the order, the program will ask the user to enter the name of the product and will loop until a valid product name is entered. The system will then responds by showing the products details and ask the user how many products he wants to order. Again, the program will loop until a correct value is entered (value not negative and not greater than the number of products in stock). When a valid quantity is entered, that amount is subtracted from the number in stock for that product and the total cost is increased by the calculated cost of the items ordered. The user is then offered the chance to add another product to the order. <heading>Data checking:</heading>The program is required to carry out the following data checking and in case of error should repeatedly ask the user for a correct value until one is entered: <list>Data entry:Ensuring that product ids entered are in the range 1000 - 1999.Ensuring that product cost and quantity in stock entered are >= 0. Placing orders:Ensuring quantities requested are >= 0 and <= the quantity in stock.</list><heading>Show total cost & place new order if user decides to:</heading>At the end of the program, the program has to show the total cost of the order that was made by the user. It should then ask him if he wants to place a new order. If he enters 'y', the program should simply restart from the placing orders part. This means that the stock available will stay the same and the user will not have to re-enter all the product details. On the other hand, if he doesn't want to restart, the program should simply end. <heading>Understanding the problem</heading><heading>Enter the three products details</heading>The first thing the user will have to do is to enter the products details so he can place orders afterwards. As required by the specification, I'll have to use records to store the information entered by the user. One record should be enough as they all contain the same type of information: <list>Name : String (because the value will contain letters)ID, Cost, Stock : Integer (because the value will only contain whole numbers)</list>In order to differentiate the three products, I will use an array that will allow me to access three times the same record and save three different products details. For example: If I declare my product like this  FORMULA  And if I declare an array that has my record as it type  FORMULA  I will then be able to store three products that have the information Name, ID, Cost and Stock. See underneath for an example that could be used to assign value to the three records:  FORMULA   FORMULA   FORMULA  In other words, my array would in fact contain the information like this: <table/><heading>Asking question & reading answers</heading>At some points in the program, the user will be asked questions (i.e Would you like to add a product to your order?) and the system will expect him to give his answer using 'y' for yes and 'n' for no. In order to know what the user wants to do, the program will use a variable char (can only hold 1 character) that will hold the answer. It will then read the variable to see what the user's answer is. If its value is 'y' then it means the user's answer to the question is yes. On the other hand if it is 'n', it means that his answer is no. <heading>Enter a product & display the product details</heading>Once the user has inputted the three products, and assuming that he wants to place an order and add a product to the order, he will have to enter the product name that he wants to add in order to show the details and then input the quantity that he wants to order. The first thing that will need to be checked is the name of the product entered. If the product does indeed exist, the program should continue and show the details of the product. On the opposite case, an error message should let the user know that this product doesn't exist and should loop until a correct name was inputted. To do so, the value entered has to be compared with all the records names. Here is an example on how it could be done:  FORMULA  There are two steps involved to display the product details. First the program has to find what product has to be displayed (this will be done in the 'if statement' shown above). Secondly the program will then display the details on the screen using a simple 'write' statement. Note: As you can see in the box, the code to display the product details, to update the stock value and to calculate the cost are there in only 3 lines. This is because we will call a procedure at that point to make the program more structured. <heading>Enter the quantity of products to order:</heading>During the order process, the user will have to enter the quantity of products that he wants to order. This will have several consequences: The program has to check that the quantity entered is valid. It must neither be higher than the quantity available in stock or below 0. The total cost of the order will have to be updated with the cost of the quantity of products added to the order. To do so, the total cost value has to be updated with the multiplication of the cost of the product by the quantity ordered. The stock available of the concerned product also has to be updated as the user ordered a certain quantity of product. To update it, the quantity of products ordered will need to be subtracted from the actual stock quantity. <heading>Consideration of the User Interface</heading>e.g. 1  FORMULA  e.g. 2  FORMULA  e.g. 3  FORMULA  <heading>Outline a basic solution algorithm</heading><table/><heading>Refining the algorithm & pseudocode</heading>To describe a program, as its name indicates it, a basic algorithm is a sort of very simplified version of the complete program. Each step of the algorithm may also contain some "sub-steps" or sub-sub-sub steps that need to be explained and refined. For this program, these are the steps that needed to be "refined": Ask for product details: in order to inform and save the program details in the program, there will be two steps involved. First, the program has to inform the user that he needs to enter some information. This will be done by outputting a message on the screen. Secondly, to save the information in the program's memory, an input from the user will have to be made. For some inputs, the program will have to validate the input: <list>The value of the product IDs' must be in the range 1000 - 1999 otherwise the user will have to re-enter a value. The value of the product Costs must be whole numbers as the value is expressed in pence.The value of the product Stock cannot be smaller than 0 because having less than no products in stock would not make any sense.</list>Asking for and placing orders: asking if the user wishes to place an order and actually allowing him to do so involve several steps. First of all, a message outputted on the screen should ask the user if he wants to place an order. Assuming the answer is yes, the program should then ask him if he wishes to add a product. If yes, the program should give the user the opportunity to enter a product name in order to place the order. If the name matches one of the records, the details should appear on the screen and the user should enter the quantity of products he wishes to order (when he is asked to do so). An update of the stock available and the total cost will be made at that point. The program will need to subtract the value of the stock available with the quantity of product ordered. Stock Available = Stock Available - Quantity Ordered The program will need to add the total cost value to the multiplication of the cost of product entered by the quantity ordered. Total Cost = Total Cost + (Product Price * Quantity Ordered) The program will loop this as long as the user wants to keep adding products to the order. Display total cost: at the end of the program, once the user has finished adding products to his order, the total cost of the order has to be shown (in pence). Ask if user wishes to place another order: after having shown the total cost of the order, the program will have to ask the user if he wishes to place a new order. If he answers yes, the program should simply loop and restart where the user has the opportunity to add a product to the order. If he does not want to, the program should end. <heading>Refined pseudocode</heading><table/><picture/><table/>Note: As you can see above, the truth table can be applied to the three products details. Although, the statements shown in the table are only applicable for the first product. These will be different for the two other products. For the right statements, compare with the refined pseudocode (page 7 & 8). <table/><table/><heading>Refine and develop the algorithm & pseudocode to deal with all conditions</heading><heading>Part 1 - Record Type and global variables</heading>As required by the specification, I have to use records, procedures and parameters passing for this work. The easiest and most effective way for me is to use one record type (which can be done in this case as the three records will have exactly the same fields) which I would relate with an array [1.. 3]. The big advantage of doing this is that I will allow me to store three different records and avoid repeating the same code many times. <table/><heading>Part 2 - Dividing the implementation of the code into procedures</heading>In order to find what should be part of a procedure in the program, the best thing to do is to try to identify the different tasks that it needs to carry out. These are: <list>Introduce programAsk user to enter the products detailsPlace an orderAsk the user if he wishes to place an orderAsk the user if he wishes to add a product to the orderEnter Name of productShow product detailsUpdate StockEnter quantity of product to orderUpdate stock value with what has been orderedCalculate Total CostDisplay Total Cost</list>As you can see above, the program can easily be spread into 7 tasks. We could use this as an example to spread the work in procedures. First of all, the 1 st task do not really need a procedure as it should be included in the "main body" of the program (begin end.). Secondly, the code for asking the products details should be in a procedure because it will need to be run at least 3 times to enter all the details. When calling the procedure, a "for loop" could be used instead of calling the procedure three times. This can be done thanks to the array and the position global variables that have been declared. The second procedure could be used to start the order placement. It will first ask the user if he wants to place an order, if yes, it will then ask him if he wants to add a product. If his answer is yes, the order placement will then began with entering the name of the product. This procedure could in fact contain all the other tasks of the program but it would make it more difficult to understand. This is why this procedure could call other procedures to make it easier. So, the last task before making any calls will be to check that the product entered does exist. The other procedures are as shown above. There will be one to: <list>Show the product details when orderingUpdate the stock with the amount of products that has been orderedCalculate the Total CostDisplay the Total Cost</list><heading>Part 3 - Main body of the program (Point 1 in Refined Pseudocode)</heading><table/><heading>Part 4 - Procedure to enter product details (Points 2, 3 and 4 in Refined Pseudocode)</heading><table/><heading>Part 5 - Procedure to place order(s) (Points 5 to 5.1.6.2 in Refined Pseudocode)</heading><table/><heading>Part 6 - Procedure to show the product details (Point 5.7 in Refined Pseudocode)</heading><table/><heading>Part 7 - Procedure to update the stock (Points 5.8 to 6.1 in Refined Pseudocode)</heading><table/><heading>Part 8 - Procedure to calculate the cost (Point 7 in Refined Pseudocode)</heading><table/><heading>Part 9 - Procedure to display the cost (Point 9 in Refined Pseudocode)</heading><table/><heading>Data Dictionary</heading><heading>Record Type variables</heading><table/><heading>Global variables</heading><table/><heading>Procedure PlaceOrder (local variables)</heading><table/><heading>Procedure Show_details (local variables)</heading><table/><heading>Procedure Update_stock (local variables)</heading><table/><heading>Procedure Calculate_Cost (local variables)</heading><table/><heading>Delphi Program Final Source Code (including comments)</heading><table/><table/><table/><table/><heading>Notes on Source Code</heading>You will notice that the order of the records, global variables declaration, procedures and main body of the program has changed a little bit. This is simply because in order (for the program) to be able to recognize all the names, procedures, etc... it needs to be written in a specific order. In fact, it simply has to be declared before using it. Although, the program also needs to show the different steps of the orders placement in the right order. This can simply be done by calling the appropriate procedure at the appropriate time. So in the program, I had to first declare the record type. Then, it uses it by declaring the global variable P which is a variable of the type of the record declared before. Secondly the program needs the user to enter the products details. Then, the program will call the PlaceOrder procedure to start the ordering process. But if you look in that particular procedure, you will notice that it calls four other procedures within it. This means that those four pieces of code must be declared before the PlaceOrder procedure otherwise the program will not be able to run as it will not recognize them. <heading>Testing Documentation</heading><heading>List of Test Cases & Test Plans</heading><list><heading>Asking Product 1:</heading>Enter a name.Enter an ID in the range 1000-1999.Enter the ID (1999) on the upper boundary of the range 1000-1999. Enter the ID (1000) on the lower boundary of the range 1000-1999.Enter 2000 to see if range works as it should.Enter 999 to see if range works as it should.Enter an ID too big for the range.Enter an ID too small for the range.Enter a cost higher than 0.Enter a cost of 0 (to test boundary limit).Enter a cost of -1 (to test boundary limit).Enter a cost of -58.Enter a stock higher than 0.Enter a stock of 0.Enter a stock of -1 (to test boundary limit).Enter a stock of -58.</list><table/><list><heading>Asking Product 2:</heading>Enter a name.Enter an ID in the range 1000-1999.Enter the ID (1999) on the upper boundary of the range 1000-1999. Enter the ID (1000) on the lower boundary of the range 1000-1999.Enter 2000 to see if range works as it should.Enter 999 to see if range works as it should.Enter an ID too big for the range.Enter an ID too small for the range.Enter a cost higher than 0.Enter a cost of 0 (to test boundary limit).Enter a cost of -1 (to test boundary limit).Enter a cost of -58.Enter a stock higher than 0.Enter a stock of 0.Enter a stock of -1 (to test boundary limit).Enter a stock of -58.</list><table/><list><heading>Asking Product 3:</heading>Enter a name.Enter an ID in the range 1000-1999.Enter the ID (1999) on the upper boundary of the range 1000-1999. Enter the ID (1000) on the lower boundary of the range 1000-1999.Enter 2000 to see if range works as it should.Enter 999 to see if range works as it should.Enter an ID too big for the range.Enter an ID too small for the range.Enter a cost higher than 0.Enter a cost of 0 (to test boundary limit).Enter a cost of -1 (to test boundary limit).Enter a cost of -58.Enter a stock higher than 0.Enter a stock of 0.Enter a stock of -1 (to test boundary limit).Enter a stock of -58.</list><table/><list><heading>Placing Orders:</heading>Place an order by entering 'y' when asked.End the program by entering 'n' when asked if I want to place an order.Add a product to order by entering 'y' when asked.Stop adding product to order by entering 'n' when asked.Enter a name of product that does not exist (assuming prod names are: 1, 2 and 3).Enter a correct name of product (assuming prod names are: 1, 2 and 3).Input a quantity to order of -5.Input a quantity to order of -1 (to test boundary limit).Input a quantity to order of 0 (to test lower boundary limit).Input a quantity to order higher than the stock available (assuming 3 are available).Input a quantity to order higher or equal to 0 & smaller or equal to the stock available (assuming 3 are available).Assuming that I have ordered 5 products that cost each 20p, enter 'n' when asked if I want to add another product and see what happens.When the thank you message appears, press any key then the enter key and see what happens.</list><table/><heading>Screenshots of Tests</heading><picture/><heading>Test - Asking Products Details </heading><picture/><picture/><picture/><picture/><picture/><picture/><picture/><picture/><picture/><picture/><picture/><picture/>As you can see above, the screenshots demonstrate that asking the product 1 details works perfectly fine. There is no need to show the product 2 and 3 details as it uses exactly the same piece of code in the program (ask products procedure - se Delphi source code). The only test that I also did to test the program is entering a correct value for the stock value of product 3 to see if the program continued with the placing orders process (see last screenshot on this page). <heading>Test - Placing orders </heading><picture/><picture/><picture/><picture/><picture/><picture/><picture/><picture/><picture/><picture/><picture/><heading>Solutions to problem(s)</heading>As indicated in the Test Plan, three problems appeared when implementing and running the program. The problem was that the program would not accept 1000 as an ID for any of the product details. This was quite important as it did not match the specification requirement. In order to solve this problem, here are the steps that I followed: <list><heading>Check the pseudocode to make sure that what was written is correct</heading>Compare with other marks procedure and see if there are any abnormal differences.If everything is normal, check the Delphi source code and make sure that it matches the final refined pseudocode.Apply the required changes to make the program work properly.</list>In this case, the source code that I wrote in Delphi did not match the pseudocode. It says in the pseudocode that while the ID entered is smaller than 1000 or greater than 1999 then, it is incorrect. When I checked my Delphi code, it is this statement that was wrong in the "ask product" procedure:  FORMULA  If you compare to the pseudocode version of this piece of code, you will easily understand where the mistake is:  FORMULA  The wrong version, does not accept 1000 and 1999 as an ID. On the other hand, the one from the pseudocode does accept it. <heading>Solving the problem & Final Result Evaluation</heading>To solve the problem once and for all, all I had to do is to modify the wrong piece of information from the Delphi source code. I could then compile the program and run it again to check that it was working as expected. If you look at the screenshots, you will see a proof that the program works as expected as it accepted the appropriate ID's. Finally, you will also notice that the program matches perfectly the program specification and design that was planned. If you compare the final version from the screenshots with the third consideration of the program, trace table and the testing, you will see that they match really well. 