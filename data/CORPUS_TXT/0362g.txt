<heading>Introduction</heading>The aim of these laboratories is to provide an introduction to some of the features of a Xilinx ISE and Spartan-3 FPGA board as well as to get familiar with VHDL codes to help write Xilinx ISE program on Spartan 3FPGA board. The codes and comments are written and programmed in Xilinx ISE 8.2i which provided the environment required to program the board. The device used in the laboratory XC3S1000 is of the family Spartan 3. The following is the table showing the summary of the device XC3S1000 FPGA in a 256 ball thin Grid Array: <table/>With reference from the handouts the main objectives of lab5 and lab6 was to carry out the following: <list>To study and understand the program ANDGATE and counter using tutorials. To follow the steps given in the laboratory handouts to create the program and then simulate it. To observe whether or not the program functioned as required. Assign pins and transfer the program to the board. Observe the results when the switches are ON To study and understand the working of Dflipflops and 7segment LEDs Define the inputs and outputs. To create program and VHDL file with codes for the working. To get graphs demonstrating the working of the codesAssign pins responsible for each inputs and outputs. Transfer the program to the boardObserve the changes or results obtained </list><heading>Theory</heading><heading>4 Digit- 7segment LEDS:</heading>The working of four 7 segment LEDs used in the board. The Spartan-3 board has a four-character, seven segments LED display controlled by FPGA user-I/O pins, as shown in Figure 1. Each digit shares eight common control signals to light individual LED segments. Each individual character has a separate anode control input. A detailed schematic for the display appears in Figure A. The pin number for each FPGA pin connected to the LED display appears in parentheses. To light an individual signal, drive the individual segment control signal Low along with the associated anode control signal for the individual character. In Figure 1, for example, the left-most character displays the value '2'. The digital values driving the display in this example are shown in blue. The AN3 anode control signal is Low, enabling the control inputs for the left-most character. The segment control inputs, A through G and DP, drive the individual segments that comprise the character. A Low value lights the individual segment, a High turns off the segment. A Low on the A input signal, lights segment 'a' of the display. The anode controls for the remaining characters, AN[2:0] are all High, and these characters ignore the values presented on A through G and DP. <picture/>Table 2 lists the FPGA connections that drive the individual LEDs comprising a seven segment character. Table 3 lists the connections to enable a specific character. <table/><table/><figure/>The LED control signals are time-multiplexed to display data on all four characters, as shown in Figure 3. Present the value to be displayed on the segment control inputs and select the specified character by driving the associated anode control signal Low. Through persistence of vision, the human brain perceives that all four characters appear simultaneously, similar to the way the brain perceives a TV display. <figure/>This "scanning" technique reduces the number of I/O pins required for the four characters. If an FPGA pin were dedicated for each individual segment, then 32 pins are required to drive four 7-segment LED characters. The scanning technique reduces the required I/O down to 12 pins. The drawback to this approach is that the FPGA logic must continuously scan data out to the displays - a small price to save 20 additional I/O pins. <heading>Slide switches:</heading>The switches are located along the lower edge of the board, toward the right edge. The switches are labeled SW7 through SW0. Switch SW7 is the left-most switch, and SW0 is the rightmost switch. The switches connect to an associated FPGA pin, as shown in Table 4. A detailed schematic appears in Figure A. <table/>When in the UP or ON position, a switch connects the FPGA pin to VCCO, a logic High. When DOWN or in the OFF position, the switch connects the FPGA pin to ground, a logic Low. The switches typically exhibit about 2 ms of mechanical bounce and there is no active debouncing circuitry, although such circuitry could easily be added to the FPGA design programmed on the board. A 4.7KΩ series resistor provides nominal input protection. <heading>Push Buttons:</heading>These push buttons are located along the lower edge of the board, toward the right edge. The switches are labeled BTN3 through BTN0. Push button switch BTN3 is the left-most switch, BTN0 the right-most switch. The push button switches connect to an associated FPGA pin, as shown in Table 5. A detailed schematic appears in Figure A. <table/>Pressing a push button generates logic High on the associated FPGA pin. Again, there is no active debouncing circuitry on the push button. The left-most button, BTN3, is also the default User Reset pin. BTN3 electrically behaves identically to the other push buttons. However, when applicable, BTN3 resets the provided reference designs. <heading>LEDS:</heading>The Spartan-3 Starter Kit board has eight individual surface-mount LEDs located above the push button switches. The LEDs are labeled LED7 through LED0. LED7 is the left-most LED, LED0 the right-most LED. Table 6 shows the FPGA connections to the LEDs. A detailed schematic appears in Figure A. <table/>The cathode of each LED connects to ground via a 270Ω resistor. To light an individual LED, drive the associated FPGA control signal High, which is the opposite polarity from lighting one of the 7-segment LEDs. <heading>Dflipflop:</heading>The operation of Dflipflop is simple. It has only one input in addition to the clock input signal. The dflipflop used in the program was positive triggered. The D input is sampled during the occurrence of a clock pulse. If it is 1, the flip-flop is switched to the set state (unless it was already set). If it is 0, the flip-flop switches to the clear state. The Figure4 shows the symbol of the Dflipflop and table 7 is the truth table and figure 5 shows the output of the Dflipflop. <picture/><table/><figure/><heading>Converting decimal into 4 bit binary number: </heading>Binary is Base 2 unlike our counting system decimal which is Base 10 (denary). In other words, Binary has only 2 different numerals (0 and 1), unlike Decimal which has 10 numerals (0,1,2,3,4,5,6,7,8 and 9). Here is an example of a binary number: 1001 is a 4 bit representation of the decimal '9'. <table/>Bit is short for Binary Digit, and each numeral is classed as a bit. The bit on the far right (in this case a zero) is known as the Least significant bit (LSB), and the bit on the far left (in this case a 1) is known as the Most significant bit (MSB) <heading>Apparatus and Method:</heading>The hardware elements featured in the laboratories were: Spartan 3 board, Digilent JTAG Cable, XC3S1000 device, USB cable to power the board. Firstly I connected Spartan 3 board to a PC and powered up board using the USB cable, followed by connecting the Digilent JTAG cable. Digilent JTAG cable is used to transfer data on to the board from the computer. I followed the tutorial given in the laboratory sheet for ANDGATE to study and understand the procedure and working of the software. I also followed the quick tutorial provided in the laboratory to make a 4 bit counter. After, the completion of the program I downloaded the program on the board and observed the results, which were as expected. I tried to relate the pins associated with each buttons, switches, LEDS, and 7 segment LEDS using the appendix A of the laboratory sheet. To make a Dflipflop program I firstly, made a note of the input and outputs needed for the program as CLK- clock input, D- D input, Q- Output. As explained earlier in theory section learned about the working of Dflipflop. I followed the method similar to the laboratory sheet provided to create and run the program. To make a counter from 0-9 on one of the four 7segment LED I used the method described in the theory to workout the codes and followed the instructions similar to those given in laboratory sheet to create and run the program. <heading>Codes Explanation:</heading><heading>DFLIPFLOP</heading><quote>library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.STD_LOGIC_ARITH.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL;</quote>Some of the files and logic defined in other locations are used in the program. Hence the above statements are used. <quote>---- Uncomment the following library declaration if instantiating ---- any Xilinx primitives in this code.  --library UNISIM; --use UNISIM.VComponents.all; entity DFLIPFLOP is ---describes the design I/O of DFLIPFLOP. Port ( D : in STD_LOGIC; ----D is an entity that goes in but not out. CLK : in STD_LOGIC; ----CLK is an entity that goes in but not out. CLK is the input clock signal for the Dflipflop. Q : out STD_LOGIC); ----Q is an entity that goes out but not in.  end DFLIPFLOP; ----end the entity of DFLIPFLOP</quote>Here in total 3 entities are described. CLK and D is input signals and Q is the output signal. Every potential connection is known as port and is given a name that is unique with in the entity. Port is a signal that contains both MODE and TYPE. MODE is the input, output or bidirectional assigned to the entity and TYPE is the value the port can take like 0, 1, 3state. <quote>architecture Behavioral of DFLIPFLOP is----describes the content of the design  begin --begins architectural behaviour</quote>In PROCESS statements are evaluated sequentially in terms of simulation. It becomes active when the sensitivity list changes the value. All signal assignments occur at the END PROCESS statements in terms of simulation time. The process then becomes in active. <quote>process (CLK) -----process is active when there is any change in input  begin if CLK'event and CLK='1' then ---this statement detects rising clock edge, using the IF condition. With the condition to detect if CLK is high i.e. '1' Q <= D; -----the output Q equals to input D everytime clock is high i.e. '1' end if; --end the condition if for CLK  end process; ---end the process for CLK and signal assignment occurs.  end Behavioral;--end the architectural behaviour of DFLIPFLOP.  7Segment LED 0-9 count: library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.STD_LOGIC_ARITH.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL;</quote>Some of the files and logic defined in other locations are used in the program. Hence the above statements are used. <quote>---- Uncomment the following library declaration if instantiating ---- any Xilinx primitives in this code. --library UNISIM; --use UNISIM.VComponents.all; entity LED7 is - describes the design I/O of LED7 Port ( ENABLE : OUT STD_LOGIC_VECTOR (3 downto 0); ENABLE is an entity that goes out but not in.  LED : out STD_LOGIC_VECTOR (6 downto 0); LED is an entity that goes out but not in CLK : in STD_LOGIC);--CLK is an entity that goes in but not out  end LED7; --end the entity of LED7</quote>There are in total 3 variables assigned ENABLE, LED CLK. ENABLE is an as described in the theory section. It is used to display the number on 7 segment LED. It can help to turn off some or turn on the four 7 segment LEDs on the board. LED stands for the 7 segments in the 7 segment LED and it helps to make it active low or high to display different numbers 0-9. CLK is used for the push button. It is assigned active high if the push button is pressed. when u push the button, the associated FPGA pin is connected to the power line (a logic "1") and when not pressed the associated FPGA pin is connected to 0V(a logic"0"). <quote>architecture Behavioral of LED7 is - describes the design of LED7  signal count:std_logic_vector (3 downto 0) :="0000";</quote>Signal carries all VHDL information. Count is an array and is assigned in a descending order count0-3 <quote>Begin - begin the architectural behaviour of LED7  process(CLK) - process is active each time input signal CLK changes  begin - begin process  ENABLE(0) <='0'; -----enable(0) is assigned 0 means it is active low hence, will help display number. Meaning that the an(0) as described in the theory section will become low and hence, the first 7 segment LED will be active low.  ENABLE(1) <='1'; -----enable(1) is assigned 1 means it is active high so it will be OFF, and will not display any number. Meaning that the an(1) as described in the theory section will become active high and hence, the second 7segnment LED will be active low.  ENABLE(2) <='1'; -----enable(2) is assigned 1 means it is active high so it will be OFF, and will not display any number. Meaning that the an(2) as described in the theory section will become active high and hence, the second 7segnment LED will be active low.  ENABLE(3) <='1'; ------enable(3) is assigned 1 means it is active high so it will be OFF, and will not display any number. Meaning that the an(3) as described in the theory section will become active high and hence, the second 7segnment LED will be active low.  if CLK='1' and CLK'event then - detects everytime CLK is rising high if count ="1001" then - checks if count is equal to '9' count <= "0000"; --then changes the count to '0'. Hence makes a loop of 0-9 and it again starts from 0 each time push button is pressed one more time after it has reached 9.  else count<= count + 1; --otherwise increase the value of count by '1' each time  end if; --end of the condition for count  end if; --end of condition for CLK  case count is when "0000" => LED <= "1000000"; --when count is '0000', display '0' on LED.  when "0001" => LED <= "1111001";--when count is '0001', display '1' on LED  when "0010" => LED <= "0100100";--when count is '0010', display '2' on LED  when "0011" => LED <= "0110000";--when count is '0011', display '3' on LED  when "0100" => LED <= "0011001";--when count is '0100', display '4' on LED  when "0101" => LED <= "0010010";--when count is '0101', display '5' on LED  when "0110" => LED <= "0000010";--when count is '0110', display '6' on LED  when "0111" => LED <= "1111000";--when count is '0111', display '7' on LED  when "1000" => LED <= "0000000";--when count is '1000', display '8' on LED  when "1001" => LED <= "0010000";--when count is '1001', display '9' on LED  when others => LED<="0000000";--when count is different value, display '8' on LED</quote>Here, the count is assigned numbers 0-9 in the binary form as 0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001 and when it is different from those it is assigned 8. The way of converting decimal into binary is explained in detail in theory. <quote>end case; --end the case for count  end process; --end the process for CLK  end Behavioral; --end the architectural behaviour for LED7</quote><heading>Assigning Pins: </heading>The following steps found in the laboratory sheet under section 3.2.4 were followed to assign pins for all the programs: <heading>3.2.4 Assigning Pin Locations </heading>1. Verify that Andgate is selected in the Sources window (Synthesis/Implementation). Then Press Processes tab. 2. Double-click the Assign Package Pins process found in the User Constraints process group. The Xilinx Pinout and Area Constraints Editor (PACE) opens. 3. Select the Package View tab. 4. In the Design Object List window, enter a pin location for each pin in the Loc column using the following information: Input "a" connected to "J13" --- User button BTN0 Input "b" connected to "K14" --- User button BTN1 Output "c" connected to "L14" --- Led LD0 5. Select File →Save. Select XST Default <> and click OK. <heading>For assigning pins to ANDGATE: </heading>The table 8 shows the pins assigned to each entity in ANDGATE program, and figure 6 shows the print screen of the assigned pins. <table/><picture/><heading>Counter: </heading>The table 9 shows the pins allocated and the figure 7 shows the pins assigned print screen. <table/><picture/><heading>DFLIPFLOP</heading>The table 10 and figure 8 shows the pins allocated for DFLIPFLOP. Here slide switches are used for inputs as it is easier than to push buttons. And also helps observing the results. <table/><picture/><heading>7segment display from 0-9: </heading>The table 11 shows the assigned pins and figure 9 shows the print screen of the assigned pins: <table/><picture/><heading>Observations and results:</heading>The simulation result of the ANDGATE is shown below: <figure/>It can be observed from the graph that c is only high when both a and b are high. Hence, it shows that the logic of c<=a and b; works. When the program was loaded on the board it showed that the LD0 was ON only when both a and b were pressed together. When pressed alternatively or not pressed at all showed no result on LD0. The simulation result of the counter is shown below: <figure/>It can be observed from the above graph that Count output for a 4 bit binary up/down counter. It can be observed that when DIRECTION input is high, the output count is incremented on the rising edge of the CLOCK input. But, when DIRECTION is set low, the output count is decremented on the rising edge of the CLOCK input. When the program was loaded on the board it showed all LEDs off. When SW7 was down position and each time BTN0 was pressed the LEDs showed a sequence of output showing the down count. But when the SW7 was in up position and BTN 0 was pressed it showed sequence of output showing the up count. Hence, it worked as required. The simulation output of the DFLIPFLOP is as shown below: <figure/>Every time when the CLK input experiences a rising edge, the output Q stores the state of the input D. However, until the CLK input goes for another rising edge, the output remains unchanged regardless of the D input. It can be noted here that the initial red line on the Q waveform represents an ambiguous condition, as the output has not been set yet. When the program was loaded on the board, LD0 was OFF. When SW0 was moved to the up position, there was still no change on the LD0 until SW1 was then moved to the up position. Once this happened, LD0 turned ON. After this, moving SW0 between the 2 states did not affect the output. However, when SW0 was in the down position, and SW1 was moved from down to up, LD0 turned OFF. Hence, the result was as expected and showed the working of Dflipflop. The simulation output of 7 segment display count 0-9: <figure/>The above graph shows that when CLK input is rising high, the output LED changes. It showed numbers from 0-9 every time when CLK input is rising high, it counted from 0-9 When it reached 9 it counted again from 0. The ENABLE output shows the correct output, as only one of the signals shows a low logic level. When the program was loaded on the board the LED displayed 0 on only one 7 segment LED. Now, every time BTN0 was pressed it showed 0-9 and when it reached 9 it started counting from 0. Hence, it worked as required. <heading>Conclusion:</heading>The programs showed the required output on the simulation graphs and also performed as required when loaded on the board. The DFLIPFLOP worked as required as it did the following: When SW1 was high and SW0 was low the LD0 was OFF When SW1 was low SW0 was high the LD0 was OFF When SW1 was high and SW0 was high LD0 was ON, until once again SW1 was high but SW0 was low. The 7 segment LED used to display count 0-9 worked as required as it did the following: It displayed 0 to start with but everytime BTN0 was pressed it displayed 0-9 on just one 7 segment LED. And when the count reached 9 and BTN0 pressed again it counted again from 0-9. 