<heading>Introduction</heading>This program is required to do two things; convert infix equations, where the operators are in between operands, to postfix, where the operators come after the operands, also to evaluate the postfix expression and come up with an answer. The program will use a stack data structure and will read the expression from an edit box, where the user shall type in the expression. <heading>Design and Implementation</heading><heading>Data Structure</heading>The data structure is defined as a stack. This means that the items are stored in a list and can only be read from and added to at the top of the list. This structure is best design with pointers. So a pointer of type stack is needed, where stack is a record with one part being the data being held and the other is a pointer to the next item in the list. With this a few functions are need; Pop, Push, IsEmpty, MakeEmpty, Readtop and Display. Pop is used to remove the top item of data from the list, not before storing the data from this element for use. Push will insert a new element with new data at the top of the list. IsEmpty will simply see if the top pointer is pointing at nil, which if it is will indicate the list is empty. MakeEmpty will remove all items from the list and dispose of all the memory leaving just the top pointer pointing at nil. Readtop is similar to pop with the exception that it does not remove the memory, it simply reads the data from the top element. Display will display all of the list's elements in a string. <heading>Evaluate Postfix</heading>This procedure is needed to read an expression written in the postfix form and solve it. Evaluating postfix would need to read through the equation, storing digits in the stack, until an operator is discovered when it will be evaluated with the next two numbers in the stack. To achieve these desired results a case statement is used to look for certain characters. For the digits 0-9 the real number is pushed onto the stack for use later on. When it comes to an operator, all the code says to do is pop the top two elements in the stack and then run the evaluate function, already declared in the program, using the operator read in. The result of this is then pushed onto the stack. If there are no more operators then this will be the answer printed out, else it will be used with operators later on in the equation. <heading>Infix to Postfix</heading>To solve the problem of infix to postfix would involve reading the equation typed in, written in infix form, and rearranging the layout. This means that a check of each character would be needed, with digits 0 to 9 being put into a string and the operators being pushed onto a stack until needed. The other problem of priority can be overcome by using the priority function already declared in the program. Implementing this code involves a case statement for each digit that could potentially occur. Digits 0 to 9 are added to a string as they come up. For the operators, they involved nested If and Case statements. These are all part of the checking procedure to see whether the stack is empty, the top element in the stack is of a higher priority or if a left bracket has occurred. After the checks, there is some similar code. With nothing in the stack the operator will be pushed straight on. However when there is an operator already in the stack the priorities are compared, if the operator in the stack is higher priority or the same, then it is popped and added to the string then the other operator is pushed onto the stack. Otherwise the operator is pushed onto the stack and then the next character is checked. When a left bracket occurs it is pushed into the stack as a marker. The right bracket, when read in runs code that will pop the stack into the string until a marker is found or the stack is empty. With all of this the concepts of operator priority, use of brackets and converting to correct postfix notation is achieved. <heading>Testing</heading>To test these procedures, I will first try very simple equations. Then once it solves these correctly I will then advance onto slightly more complex equations until eventually I will have an equation with multiple brackets and several different operators. At each stage, should the conversion or evaluation not run correctly, I shall implement alterations to the code when needed. This same theory of testing can be applied to both infix to postfix and evaluating postfix. As the infix equation becomes more complicated so too will the postfix to be evaluated. Below is a table comprising of the equation used, the postfix conversion and the evaluated postfix. These are printed in the order of testing. <table/>As seen here the equations typed in got progressively more complex and began to introduce new components such as brackets and power. Following are a couple of screenshots showing what is seen when the procedures are executed. <picture/><picture/> FORMULA  