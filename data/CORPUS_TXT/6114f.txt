<heading>Part A: The Bracketing Method</heading><heading>Introduction</heading>For the first part of this project the bracketing method was used to solve the solution to x=exp(-x) iteratively. Before commencing the writing of the program itself, it may be useful to explain how the bracketing method works. The bracketing method is very simple and will always iterate toward a true solution unlike some other iterative methods (such as Newton-Raphson). If you imagine some arbitrary values of a function f(x) such that f(x 1)<0 and f(x 2)>0 we know that the true solution (or root) of the function lies in the range x 1<x<x 2. If you take a further point, exactly halfway between x 1 and x 2, say x mid then if f(x mid)>0, you know immediately the solution lies somewhere between x mid and x 1 else the solution must lie between x 2 and x mid. At this point, it may be worth mentioning x mid can be calculated by (x 1-x 2)/2. In doing this, we have halved the size of the original range where the root must lie. If the root lay in the region x mid and x 1, then you would simply call x mid=x 2 now and repeat the process, and likewise if it lay in the region between x 2 and x mid then call x mid=x 1. Continuing this process of reducing the size of the region where the true solution can lie is called iteration and continuing to half the region where the solution lies will eventually narrow the root down to some value which is accurate enough for use. The bracketing method is unconditionally convergent; the root always lies in the new region after each step of iteration. The convergence rate is clearly defined. This will be discussed in detail later along with the accuracy and uncertainty of the bracketing method. The convergence rate produced by the program will also be analysed. <heading>The Program</heading>A equation was given such that x=exp(-x) and the task in hand was to solve this iteratively. To do this f(x) needed to be equal to 0 (f(x)=0) and hence x=e -x had to be rearranged from the initial equation that was given to 0=exp(-x)-x. A function was then defined as f(x)=exp(-x)-x and at this point a MATLAB function was also defined, fun.m (see appendix) that would be used to solve the problem iteratively. After defining the function, a program exp.m (see appendix) was written to solve the problem iteratively using the bracketing method described previously. Three arrays were defined to store the values of xlow, xhigh and xmid and then used a loop to find the iterative solution to the function fun.m. The program was written to plot a graph of the xlow and xhigh arrays so that graphically I could see them converging on the correct result. The way the bracketing method works requires one value of x to be positive and the other to be negative in comparison to the true solution for it to iterate correctly, with that being the case some values had to be chose such that the xlow value and the xhigh value that gave solutions with different signs (that is f(x)<0 and f(x)>0). Having defined the function fun.m, at the MATLAB prompt one can select some values of x by simply entering fun(z), where z is any real number in order to get the solution at that value of z. The values of fun(0) and fun(5) (Figure 1) were tried and had solutions values of 1 and -4.99326205300091 respectively. These values were therefore suitable for xlow and xhigh because the solutions had different signs. In the program therefore xlow and xhigh were defined xlow=0.0 and xhigh=5.0. <figure/><heading>Results</heading>With these initial conditions and the number of iterations n set to n=10 the program was ran. The x low value was 0.56640625000000 and the xhigh value 0.57128906250000 and so it was fairly clear at this point that the program was working and converging on a solution somewhere between 0.56 and 0.57. The graph shown in Figure 2 shows very clearly the way the program is beginning to converge to a single solution. You can see the solution starting from the xhigh value of 5 and converging down to the true solution. You may notice the xlow value appears to start at 4 instead of 0, this is because of the way the bracketing method works. When the iteration started, for the first four iterations xlow stays as 0. This is because xlow was closer to the true solution that xhigh. <figure/><heading>Analysis of Results</heading>After each timestep the root lies within a range half of the previous range and as such, the solution is linearly convergent on the root. The uncertainly after n iterations can be written as Îµn and so  FORMULA  which merely says the error at the next timestep is half that of the previous timestep. In the case above, the interval was from [5,0] and so after the 10 iterations the root is known to an accuracy of  FORMULA   FORMULA  After 10 intervals the region is which the solution lies is reduced by a factor of 1024.The uncertainty after 10 iterations is 0.004882815 which when considering many real life problems would probably be accurate enough for use, however the time that this iteration program takes to run on a computer is so small you could use many more iterations to get a more accurate solution without a noticeable increase in time taken. The program was run to find the correct solution to four decimal places. After 17 iterations, the low value of x became 0.56713104248047 and the high value 0.56716918945313, which as you can see when truncated to four decimal places, gives the answer of 0.5671. The graph in Figure 3 shows the convergence graphically. After 10 iterations, you can see the solutions already look very close. <figure/>The uncertainty in this result can be calculated by using  FORMULA  which gives an uncertainty of 0.000038146. The size of the interval has been reduced by a factor of 131072. If you round the solution it becomes 0.5670 correct to four decimal places after 20 iterations. The low value becomes 0.56714057922362 and the high value becomes 0.56714534759521 and once you truncate to four decimal places and round correctly, the solution becomes 0.5670. The graph in Figure 4 shows the converging results. <figure/>The uncertainty in this result can be calculated by using  FORMULA  which gives an uncertainty of 0.000004768. The size of the interval has been reduced by a factor of 1048576. Vary the initial starting conditions from [5,0] to say [100,-100] then the rate of convergence changes. With 10 iterations the solutions of 0.3906 and 0.5859 from the arrays which is somewhat different to the values found previously. The uncertainty in this result is 0.1953125 which is much larger than the uncertainty after 10 iterations with conditions [5,0]. Figure 5 shows how the solution converged onto a solution. The way the iterative method works means that the closer you start to the true solution then the quicker you are able to lower to uncertainty and converge to the iterative solution. <figure/><heading>Part B: Atmospheric Trajectories</heading><heading>Introduction</heading>The two dimensional flow that forms when a small amplitude Rossby wave hits a critical layer in the atmosphere can be described by the following Stewartson-Warn-Warn streamfunction:  FORMULA  The atmospheric flow contains eddy regions and stream regions. Eddy regions are regions in which air parcels move along a close trajectory whereas stream regions describe regions in which air parcels are not "closed in". The velocity of the flow is given by the following equations  FORMULA   FORMULA  The program is going to be written to calculate the trajectory of an air parcel that starts from some position (x o,y 0) and time t=0. An explicit forward scheme will be used to calculate the first step and from then on a leapfrog scheme with a Robert-Asselin filter. <heading>Writing the Program</heading>The first step in writing the program is to convert the given equations into a format that can be used to produce a numerical scheme. The first scheme needed is the explicit scheme which can be written as  FORMULA   FORMULA  This format is of little use to use for solving as it stands and some manipulation needs to be done the formula yet. Solving for u  FORMULA   FORMULA   FORMULA  Approximating to finite difference gives us  FORMULA  And thus the correct explicit scheme to use for x is  FORMULA  Solving for v  FORMULA   FORMULA   FORMULA  Approximating to finite difference gives us  FORMULA  And thus the correct explicit scheme to use for y is  FORMULA  After transforming the equations into something more useful a program was written to solve the problem of atmospheric trajectories. The initial variables were first defined for x 0 and y 0, the initial starting point of the parcel as well as n, the number of steps, alpha for the coefficient of the Robert-Asselin filter and t and dt for the timesteps. One step of explicit forward was used to get the first values of x 1 and y 1 and then a leapfrog scheme with a Robert-Asselin filter (coefficient 0.01) was used from thereon. The program was written and given a filename of traj.m (see appendix). <heading>Results</heading>The program was run with the following variables set, x0=1, y0=1, n=2000, alpha=0.1, dt=0.01 and t=0.0. Running the program from the starting point [1,1] from t=0 to t=20. Figure 6 shows the graphical solution of this result with x and y plotted as standard. The closed region (or eddy region) is closed which is what is expected. Although it does not show up very clearly in Figure 6 there is a number of loops around the larger loop that is clearly visible, but they are all very close to each other. This is what happens as a parcel circulates around an eddy region. <figure/>The starting conditions were changed such that [1,2] was now the start point and the program was run. Figure 7 shows the graphical solution of running the program now. This part of the program shows what is expected when a parcel is projected in a stream region. <figure/><heading>Implementing a Weak Time-Dependent Perturbation into the Program</heading>The streamfunction already considered is time-independent and as such the trajectories are not chaotic. A time-dependency factor can mean the streamfunction will become chaotic and so the program is going to be modified to include a weak time-dependent perturbation. The streamfunction now becomes  FORMULA  From the streamfunction the velocity fields must be deduced before a computer program can be written.  FORMULA   FORMULA   FORMULA   FORMULA  Now two new velocity fields have been calculated the computer program can be written. <heading>Writing the Modified Program</heading>The majority of the first program traj.m could just been modified for the new program that was being written. Three new variables were introduced that related to the sin function of the velocity field v. The u component of the velocity field remains unchanged and so there is no need to make any modification to this part of the program, however the v component has changed and now contains a weak time-dependent perturbation. Modifications were made to the lines of code in the program that contained the v component. After modifications were made to the code, the program was saved as time.m (see appendix). <heading>Results</heading>The program was run with the following initial conditions, x0=1.0, y0=1.70, n=2000, alpha=0.01, dt=0.01, t=0, e=0.1, k=1 and c=3. Running from [1,1.7] from t=0 to t=20 the graph in Figure was output from MATLAB. The initial starting condition of [1,1.7] is clearly visible and it shows that initially the parcel almost completes an orbit before continuing off in some other direction. The outcome of this looks very similar to a mixture of the parcel being in the eddy region and the stream region. <figure/>The initial conditions were varied slightly such that the starting point was now [1,1.71] and the graph shown in Figure 9 is what was outputted by MATLAB. The initial starting condition is shown again fairly clearly however the graph shows that the parcel beings to loop in what must be the eddy region. It is interesting to notice that a change of 0.01 in the y value has caused such a change to what the graph looks like. <figure/>The program time.m was run with initial conditions [1,1] with e=0 and hence this should replicate the first experiment carried out in without time dependency. It was also run with condition [1,2] and e=0 to replicate the second experiment. The expected outcome would be for the values to be the same as by setting e=0 the program is basically ignoring the time-dependency. The results are given below. <table/>The results from traj.m are the same as those from time.m when e=0 (i.e. no time-dependency). The results in the table they are exactly the same as the predicted ones and hence some confidence can be taken in the programming of the weak time-dependent perturbation that has been programmed into the program. <heading>Analysis of Results</heading>Initially looking at the results it would seem the modified system displayed chaotic behaviour, which means that the system is extremely sensitive to the initial conditions. In the experiments run the conditions were changed slightly from [1,1.7] to [1,1.71] and some very different results were obtained. In order for a system to be chaotic, it is necessary for the system to be two dimensional with time forcing or three dimensional. In all the experiments carried out in part B the systems were two dimensional so it is possible to discard the three dimensional argument already. In the first set of experiments where Figure 6 and Figure 7 where the graphical outputs the system was simply two dimensional and had no time dependence. Changing the initial conditions from [1,1] to [1,2] caused a change in the output but the difference was significant and at each point the system displayed consistent behaviour. The system was also not sensitive to initial conditions as can be seen in Figure 10. The initial conditions were changed from [1,1] to [1,1.1] and the graph looks almost identical to that in Figure 6. Figure 6 and 10 displayed some sort of circular orbit whereas Figure 7 displayed sinusoidal motion. Changing the conditions from [1,2] to [1,1.99] also gave a sinusoidal graph. <figure/>In the second set of experiments when a weak time-dependent perturbation was introduced into the program, changing the initial conditions altered the outcome dramatically. The difference between Figure 8 and 9 is significant and yet they only had a starting difference of 0.01 in the y. Further small changes led to a difference in the y led to a drastically different answer with no obvious pattern. The table below shows how holding x constant and varying y over a very small interval gives very different final results for x and y. <table/>The results show that adding a weak time-dependent perturbation into the program has caused it to exhibit chaotic behaviour. There is little way of predicting what might happen because small changes are causing such big differences in the final result. Considering the program is being run over just 2000 intervals, increasing this will only increase the chaos in the program and predictions of what might happen in the future become even more impossible. 