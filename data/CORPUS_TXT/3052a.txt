<heading>Discussion of the program:</heading>This program is made up of 3 functions: ExecuteCommandLine, main and  NumberSpace. <heading>The main function:</heading>The main function prompts the user to enter a command line. This command line can be 'exit' if the user wants to quit the program. This main function contains a main loop which runs until the user enters 'exit'. After the user has entered a command line, the function fork() is called in order to create a child process which will execute the command line. This child process calls the function ExecuteCommandLine (see below to have more explanation) and the parent process waits its child end with the function wait(). After the child process ends, the parent process tests what the child process returned in order to inform the user about the error if that is what happens. The following schema explains this process: <figure/>The prompt message follows,  FORMULA  <heading>'ExecuteCommandLine' function:</heading>This function is called by the child process. The purpose of this function is to analyse the command line (analyse the pathname and the arguments) and then to execute this command line. This function has just one parameter, a string which is the command line. This function creates an array (char**, array of array of char) which will contain the pathname and all the parameters. This array is called args in the program. In order to "extract" the argument from the command line, a "while loop" is used. This loop reads the command line character by character and then fills the array. The following schema show how is structured this array: <figure/>After the array is filled, we can call the execv function which executes a program. This function is a member of the exec family. The synopsis of this function is,  FORMULA  Where path is the pathname of the program and argv[] is an array (array of array of char) which contains all the argument which have to be added to the command line (after path). If no error has occurred, then the child process closes and the parent process wakes up. However, if an error has occurred, then the child process closes and returns the integer 2. Then the parent process catches this integer and informs the user about this error. <heading>'NumberSpace' function:</heading>This simple function returns the number of space in a string. It's called by the function ExecuteCommandLine in order to count the number of argument in a command line. For example, if the command line is: "./myprog arg1 arg2" then this function should return the integer 2 (because there are 2 space), so there is 2 arguments in the command line. Then, ExecuteCommandLine add 1 to this number in order to count the pathname. So there are 3 argument within which the pathname. <heading>Printout of a compilation:</heading> FORMULA  We can see above that the compilation has no error. There is only one file, so no '.o' file are created. <heading>Printout of program source code:</heading> FORMULA  <heading>Test data:</heading>In this following printout, we can see several tests in several cases.  FORMULA  In this example several command line are entered until the user has entered 'exit'. <list>'hello' needn't argument and printouts a simple message'helloarg' is a simple program which printouts all the arguments' blabla' doesn't exist => child error => parent informs userSome tests follow using the program 'ls' (/bin/ls)</list> FORMULA  <heading>Reflection on results:</heading>Expected results are similar than the results which are obtained. The user can enter commands line with any arguments necessary. He can do that until he enters 'exit'. The command line is executed by an child process and the parent process wait for the end of the child process. If an error has occurred, then child process returns a special integer (2) and then the parent process inform the user about this error. <heading>Conclusion on the problem:</heading>The system function fork(), wait() and exec() allow to a process to delegate some tasks to another process (its child process). While the child process executes, the parent process can wait its child process or do another task. It can be very useful when a program has to execute the same task several times. For example, if a program has to execute a task (which can be a program execution) 4 times, it can create 4 child process which will execute this task in the same time (parallel execution). 