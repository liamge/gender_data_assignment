<heading>Part 1: Communication and synchronisation mechanisms and formal method definition. </heading><heading>Semaphores, monitors and message passing</heading><heading>Semaphores</heading>A semaphore (invented by Edsger Dijkstra) is a protected variable and represents the classic method for restricting access to shared resources (e.g. memory) in a multiprogramming environment. Semaphore is a non-negative integer with value initialized to the number of corresponding shared resources it is implemented to control (if there is only one resource, it is a binary semaphore with value 0 or 1). The current value is the number of units of the resource which are free. Semaphore "is accessed by means of two special operations, P and V. If s is a semaphore, V(s) increments the value of s, and P(s) delays its cellar unit s is positive and then decrements s. A V is used to signal the occurrence of an event, and a P is used to delay until the event has occurred." (Olsson, R, 2004) Notice that incrementing the variable s must not be interrupted, and the P operation must not be interrupted after s is found to be nonzero. This can be done by special instruction or by ignoring interrupts in order to prevent other processes from becoming active. That is why P and V operations must be atomic, which means that no process may ever be pre-empted in the middle of one of those operations to run another operation on the same semaphore. The canonical names P and V come from the initials of Dutch words. V stands for verhoog, what can be translated into increase. Several explanations have been given for P (including passeer meaning pass, probeer meaning try, and pakken meaning grab), but in fact Dijkstra wrote that he intended P to stand for the made-up portmanteau word prolaag, short for probeer te verlagen, meaning try-and-decrease. This confusion stems from the unfortunate characteristic of the Dutch language that the words for increase and decrease both begin with the letter V, and the words spelled out in full would be impossibly confusing for non - Dutch-speakers. In software engineering practice the P and V operations are called wait and signal, or take and release, or pend and post. To avoid busy-waiting, a semaphore may have an associated queue of processes. If a process performs a P operation on a semaphore which has the value zero, the process is added to the semaphore's queue. When another process increments the semaphore by performing a V operation, and there are processes on the queue, one of them is removed from the queue and resumes execution. <heading>Different kinds of Semaphores:</heading>Counting Semaphores - can take integer values. "An instance of a counting semaphore is a single count. For example if the count is five, then that semaphore has five instances. Similarly if the count is zero, semaphore has no instances." (Lamie, E. 2004) The P operation takes one instance from the counting semaphore by decreasing its count. If the count is equal to zero instance must wait in a queue. Similarly, the V operation places the instance in the counting semaphore by incrementing its count. Binary semaphore - the simplest kind of semaphore used to control access to a single resource. It is always initialized with the value 1. It "only takes values 0 and 1, like locks. (...) Just like locks binary semaphores must be acquired and released, and only one process can hold a given semaphore at a time." (Kent A.al. 1990)When the resource is in use, the accessing thread calls P to decrease this value to 0 and lock access to this resource. Only the current owner can unlock the semaphore so when resource is ready to be freed it is restored to 1 with the V operation. Blocking semaphore - a binary semaphore that is initialized to zero. This has the effect that any thread that does a P operation will be blocked until another thread does a V. This kind of construction is very useful when the order of execution among threads needs to be controlled. (Wikipedia, 2007) <heading>Monitors</heading><quote>"Many modern software systems consist of collections of cooperating tasks. In such systems, mechanisms for arranging exclusive access to resources and for synchronizing and communication among tasks are needed. Many such mechanisms have been proposed, including semaphores and various forms of message passing. One of the most natural, elegant, and efficient mechanisms for synchronisation and communication, especially for shared-memory systems, is the monitor." (Belzer J.al. 1987)</quote>A monitor can be used for synchronizing two or more computer tasks that use a shared resource. Not only it ensures task an exclusive access to resources, but also to synchronize and communicate with other tasks. A monitor consists of: <list>Entry routines Mutual exclusionDate items- the variables associated with the resourceMonitor invariant - defines the assumptions needed to avoid race conditions</list><heading>Entry routines and Data Items</heading>A contains a set of data items and a set of procedures, called entry routines that operate on the data items. The monitor data items can represent any resource that is shared by multiple tasks. A resource can represent a shared hardware component (e.g. hard drive) or a software component (e.g. file). Generally monitor data can be manipulated only by the set of operations defined by its entry routines. (Belzer J.al. 1987) <heading>Mutual exclusion</heading>Mutual exclusion is enforced among tasks using a monitor - only one task at a time can execute (called 'active task') a monitor entry routine. Mutual exclusion is enforced by locking the monitor when execution of an entry routine begins and unlocking it when the active task gives up control of the monitor. If another task invokes an entry routine while the monitor is locked, it is blocked until the monitor becomes unlocked. <heading>Monitor invariant</heading>The monitor invariant in this case simply says that the balance must reflect all past operations before another operation can begin. It is usually not stated in the code but may be mentioned in comments. There are however programming languages like Eiffel, which can check invariants. (Wikipedia, 2007) <heading>Condition variables</heading>To avoid entering a busy waiting state, processes must be able to signal each other about events of interest. Monitors provide this capability through condition variables. When a monitor function requires a particular condition to be true before it can proceed, it waits on an associated condition variable. By waiting, it gives up the lock and is removed from the set of running entry routines. Any process that subsequently causes the condition to be true may then use the condition variable to notify a process waiting for the condition. A process that has been notified regains the lock and can proceed. <heading>Message passing</heading>In computer science, message passing is a form of communication used in concurrent programming, parallel programming, object-oriented programming, and inter-process communication. "The basic operations in message passing languages are "send a message" and "receive a message." Since a message must be sent before it can be received, message passing imposes an causal order on the actions of the program" (John H., 1999). Destination of a send operation and the soured of receive, seen as a pair, is called communication channel. Forms of messages include function invocation, signals, and data packets. There are few different models of message passing. As fundamental the message passing model is defined as: <list>set of processes having only local memory processes communicate by sending and receiving messages the transfer of data between processes requires cooperative operations to be performed by each process (a send operation must have a matching receive</list>Other models include: <list>data parallelism - data partitioning determines parallelism shared memory - multiple processes sharing common memory space remote memory operation - set of processes in which a process can access the memory of another process without its participation threads - a single process having multiple (concurrent) execution paths combined models composed of two or more of the above </list>(Maui High Performance Computing Centre, 1996) Message passing uses two communication mechanisms: Asynchronous message passing mechanism buffers the communication between sender and receiver. That allows the sender to continue execution after sending a message. This is analogous to mailing a letter - once a letter is in postbox, the sender can continue with other tasks. Synchronous message passing - after sending the message the sender is blocked until its massage is received. This is analogous to making a phone call, where the caller must wait until someone picks up the phone before talking. (Reppy J., 1999) <heading>Formal Methods</heading>Formal methods are mathematically-based techniques for the specification, development and verification of software systems. They are based on mathematical theories, such as: algebra, temporal logic, finite-state machines, functional programming or Petri nets. The use of formal methods for software design is motivated by the expectation that, as in other engineering disciplines, performing appropriate mathematical analyses can contribute to the reliability and forcefulness of a design. The high cost of using formal methods implicates that they are usually only used in the development of systems, where safety or security is crucial. Formal methods are rapidly becoming a promising and automated technique used at an early stage during the process of software development. The reason for that is that most of the cost of software development branch from design (or requirements) defects. It is obvious that defects detected in design cost hundred times less then the ones detected in testing or maintenance phase. Formal methods enable us to identify those defects at the early stage of software life cycle. As a result we can reduce cost of debugging, maintenance, and re-development. Moreover formal methods give us greater confidence that safety-critical systems meet the desired properties in order to avoid disastrous consequences. Many techniques with various degrees of rigor have been used in formal methods for specification, modelling, and verification. (Juan, E. et al., 2002) Formal verification methods can ensure that a high-level system design really meets rigorously specified correctness requirements, thereby increasing the possibility that faulty designs can be discovered at the early phases of system development. The other advantages of using formal methods are: In the process of formalizing informal requirements, ambiguities, omissions and contradictions will often be discovered. The formal model may lead to hierarchical semi-automated (or even automated) system development methods. The formal model can be verified for correctness by mathematical methods (rather than by intractable case by case testing). A formally verified subsystem can be incorporated into a larger system with greater confidence that it behaves as specified. Different designs can be evaluated and compared. (Ostroff J. 1992) <heading>Part 2: Real-time application</heading><heading>1. MULTI-STOREY PARKING SYSTEM</heading>The application which I decided to describe is a system which works in a multi-storey car park. System is provided for car park to monitor and control cars entering, leaving and staying inside the facility. For the purpose of this coursework I made an assumption that car park has 200 parking places and 3 floors, with entrance gate on each of them and exit with pay centre situated on the ground floor. Each space has its own sensor, which can tell if it is occupied or not. Thanks to the sensors system can say how many places are still available and where exactly they are located in the building. This information is provided to driver who should find a parking space without senseless driving around the floors. Car will not be let in if there is no space to park. My system is also capable of calculating amount of money to be paid when car is leaving the parking. Payment is dependent on the time spend in the facility. While designing the real-time applications we must ensure that it meets not only functional but also timelines requirements. The Multi-Storey Parking System is a soft real-time system. "A soft real-time system is one in which performance is degraded but not destroyed by failure to meet response-time constraints." (Laplante P., 2004). For my system it simply means that if driver will have to wait e.g. 5 seconds before he will obtain detailed directions to find his parking space, no serious damage is made. <heading>Processes Description</heading>Multi-Storey Parking System contains following processes: <list>Display Panel - Gate 1 2 3:Informs driver how many (if any) free spaces are left. It communicates with update process to update the number of free spaces. It displays the way to the parking place.Update:This process communicates directly with the Central Panel to obtain number of free spaces available at the moment. Afterwards it sends the information to the Display Panels on Gate 1, 2 and 3.Ticket Machine - 1 2 3:Ticket machines, assigned to each Gate, after being asked for a ticket by Display Panel check if any place is available, and book it in Central Panel (it means that the number of free spaces is decreased). If the place is booked successfully the information including directions is sent to Display Panel and ticket is given. If there is no space left information: 'Sorry we do not have any free places left. Please wait.' appears on the Display Panel.Park:Car parks on a free space. This activates the sensor of this place.Leave:Car leaves the parking place. This deactivates the sensor of this place.Sensor - 1 to 200:Each parking place has its own sensor which is activated every time a car parks on this place and deactivated every time a car leaves the place. Sensor process sends information about a parking car to the Central Panel so that the current localization of free spaces can be updated. The number of free spaces is not updated by this process as the car leaving the place does not have to leave the parking (it can park on some other place).Pay Centre:When driver gives the ticket to Pay centre its details are send to Central Panel in order to acquire data of how much time this car spent inside the car park and how much should be paid. When money is paid Pay Centre updates availability of free spaces in Central Panel (now we can be sure that the car has left).CENTRAL PANEL:This process has access to availability details. It gives information how many places are available, and where they are located. In order to be constantly updated It communicates with Ticket Machine, Update, Sensor and Pay Centre. </list><heading>Processes I/O</heading><table/><heading>Scenario I (One car at one gate)</heading><list>Gates:Gate 1 - no carGate 2 - no carGate 3 - 1 carDisplay panel on gate 3 checks how many free parking places are leftInformation is updated from central panel :Availability = 5Driver asks for a ticketTicket machine checks again with the central panel and books a placeResponse to ticket machine on gate 3: 5 places available; book 1 and show the way, decrease free places number to 4Central panel sends localization of the place to the ticket machineInformation is updated on each gate from central panel :Availability = 4Ticket machine gives ticket and shows the wayCar parked in destined placeSensor activatedSensor send localization details to main serverMain server checks if the car is parked in correct place. It is.Car is parkedCar leavesSensor is released and central panel is updatedPay centre takes a ticket and sends ticket details to central panelCentral panel answers with period of time that the car spend in the parking and amount of money to be paidAvailability information in central panel is updated when money is paidInformation is updated on each gate from central panel :Availability = 5Car goes toward the exit</list><heading>Scenario II (One car at each gate)</heading><list>Gates:Gate 1 - 1 carGate 2 - 1 carGate 3 - 1 carDisplay panel on each gate check how many free parking places are leftInformation is updated on each gate from central panel :Availability = 2Drivers asks for ticketsGate 1 asks for a ticketGate 2 asks for a ticketGate 3 asks for a ticketTicket machines check again with the central panel and book a placeResponse to ticket machine on gate 1: 2 places available; book 1 and show the way, decrease free places number to 1. Send localization of the place to the ticket machineInformation is updated on each gate from central panel :Availability = 1Response to ticket machine on gate 2: 1 place available; book 1 and show the way, decrease free places number to 0. Send localization of the place to the ticket machineInformation is updated on each gate from central panel :Availability = 0Response to ticket machine on gate 3: 0 places available.Ticket machines:On gate 1 and 2 give tickets and show the wayOn gate 3 display 'Sorry we do not have any free places left. Please wait.'Car from gate 1 and 2 parked in destined placeSensors activatedSensors send localization details to main server:Sensor responsible for the car from gate 1Sensor responsible for the car from gate 2Main server checks if the cars are parked in correct places.Car 1 is.Car 2 is.Cars from gate 1 and 2 are parkedTicket machine on gate 3 checks availability with the central panel: Availability =01 of parked cars leaves parking placeSensor is released and central panel is updatedPay centre takes a ticket and sends ticket details to central panelCentral panel answers with period of time that the car spend in the parking and amount of money to be paidAvailability information in central panel is updated when money is paidInformation is updated on each gate from central panel :Availability = 1 Car goes toward the exitTicket machine on gate 3 checks availability with the central panel: Availability =1Driver asks for a ticketTicket machine on gate 3 checks again with the central panel and books a placeResponse to ticket machine on gate 3: 1 place available; book 1 and show the way, decrease free places number to 0Central panel sends localization of the place to the ticket machineInformation is updated on each gate from central panel :Availability = 0Ticket machine gives ticket and shows the wayAnother car leaves his parking placeSensor is released and central panel is updatedPay centre takes a ticket and sends ticket details to central panelCentral panel answers with period of time that the car spend in the parking and amount of money to be paidAvailability information in central panel is updated when money is paidInformation is updated on each gate from central panel :Availability = 1 Car goes toward the exitCar form gate 3 parked in released place (incorrect)Sensor activatedSensor send localization details to main serverMain server checks if the car is parked in correct place. It is not.Central panel is updated with new car localization.Car is parked</list><heading>2. Data Flow Diagram</heading><figure/><heading>Part 3: Definition of concurrent process and synchronisation mechanisms. </heading><heading>1. Concurrent Processes</heading>Multi-storey parking system processes' concurrency is dependent on the number of cars which are currently inside the facility. When car park is empty the only processes that work are the Display panels on all three gates, which wait for a car to come (they work all the time). When first car arrives one of the gates exchanges the data with Update process and concurrently with ticket machine. That means that Central Panel starts working parallel. Than car parks, that activates the Sensor which updates Central Panel. When car leaves Sensor is deactivated, that updates Central Panel. Ticket is putted into Pay centre process, which again exchange data with Central Panel. Finally car goes toward Exit. As it is easy to notice when there is only one car in car park it does not happen to often that other processes than Gate processes run at the same time. Situation changes dramatically when parking is full. When there are more cars in the car park where, some of them are parked, some want to park and some are leaving the building, all of the processes work concurrently. From all this processes that take place when parking is busy I believe that process Park, Leave and Display Panels on gates are the processes which require the most attention when concurrency is taken into account. I decided to use semaphores as inter-process communication and synchronisation mechanisms. Process Park uses semaphores to lock the place where the car is parked. Process Leave unlocks semaphores when car leaves the parking place. Display Panels on Gates are also based on semaphores as only one car can go threw the gate at one time. <heading>2. SR program</heading>The program below simulates working of Multi-storey Parking System. With processes: <list>Parking - simulates the process of parking a car.Leaving - process of leaving the car park.Clock - counts the time.Gate 1, Gate 2, Gate 3 - they set the probability of appearing of the car at each gate.</list><heading>Source code</heading> FORMULA  <heading>Output</heading>Though the program above is wrote for 200 parking places this output is from the program in which the number of places was decreased to 5 what illustrates better working of the system.  FORMULA  