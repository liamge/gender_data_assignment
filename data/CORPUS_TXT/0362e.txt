<heading>Introduction</heading>The aim of these laboratories is to provide an introduction to some of the features of a microcontroller (M16C/62) from the Mitsubishi M16C family as well as those of a program that provides an integrated development environment (IDE) for the creation and testing of application programs. The codes and comments are written and programmed in IAR Embedded Workshop which provided the integrated development environment required. The microcontroller had two 7 segment display devices and 3 push button switches. The port responsible for the segments output was port P0 and the port responsible for the enabling the LED's output was port 1. With reference from the handouts the main objective of these laboratories was to carry out the following: <list>To study and understand how to relate Appendixes A and B to this program To comment on every line of this program To change the delay section of the program Assi1.c and observe the action To modify the program Assi1.c to rotate continually one segment clockwise on LED 1To use SW1 to stop/start the rotation of the LED1 segment in the Assi1.c programTo determine the missing codes required to drive the display devices to show the current value of the count as two decimal numbers ('tens and units') on LED 1 and LED 2 in Assil2.c</list><heading>Theory</heading>I used the Appendix A to determine how the two 7 segment display devices must be driven on a time-multiplexed basis and to identify the microcontroller I/O pins involved and the voltage levels required to activate both particular display device and the individual segments. I used the Appendix B to determine the special function registers associated with the I/O pins used. The Appendix C for the codes given With the knowledge I had and understanding the lectures notes I wrote the codes and comments for the programs <heading>Apparatus:</heading>The hardware elements featured in the laboratories were: the microcontroller input/output (I/O) ports, 7 segment display devices and push button switches. Firstly I connected the M16C Microcontroller board to a PC and powered up both boards. The codes and comments were written and programmed using IAR Embedded Workshop which gives integrated development environment required for creating and testing the applications. With the reference from the handouts given, the two program files Assi1.c and Assl2i.c carried out the following operations: Assi1.c- It keeps a running count (mod 10) in the LED 2 display Assil2i.c- It contained an incomplete program for the microcontroller to count (modulo 100) the number of times switch SW1 was operated and display the result. <heading>Working Explanation:</heading>SW1 -It is drive by 5V using 10K register (R16) and has PIN20 which is connected to the microcontroller through 96 way connector CN4-A and has been assigned Port8 bit 2. Port 8.2 direction register is used to set the direction and port 8.2 register is used to set it low or high. When it is pressed it grounds the port making it active low. <picture/><table/><table/>7 Segments display device- Port 0 which is a 8 bit port, is responsible for the 7 segments display and one bit is assigned to the each segment as shown below: <picture/>Port 0 direction register is used to set the direction of the segments and Port 0 register is used to set it pulled high or low. Here as shown in figure, OE is always active low as it is connected to ground and according to the function of 74HC244 it displays only the active low from all the inputs. Here the input is the 7segments. <picture/>LED1 & 2: The connection details of the LED1 & 2 and the port 1 responsible for the enabling process are as shown above. The LED has an Enable pin. This is controlled by port 1 bit 0 for LED 1 and port 1 bit 1 for LED 2. Port P1 direction register is used to set the direction of LED and Port P1 register is used to set it low or high. <figure/><figure/><heading>Collective working of both LED and Switch :</heading>Firstly, the direction of switch SW1 is set to input. The port responsible for SW1 is P8.2 and by using the Port 8 direction register(mentioned above),PD8.2 is assigned 0. The code for this application is PD8.2==0; Now, the direction of both LED1and LED2 has to be set to output. The port P1.0 is responsible for LED1 and P1.1 is responsible for LED2. Using the information on Port 1 direction register, PD1.0 and PD1.1 is assigned value 1. The codes for this application are: <quote>PD1.0==1; PD1.1==1;</quote>To set the direction of 7 segments to output, PD0 is responsible. Here, all the 8 bits of 8 bit port has to be assigned to output. Also, all the port 0 directions registers of all the segments has to be assigned 1. This can be done by using bytes to represent all the bits of port 0. <table/>Here, 8+4+2+1=15=F and 8+4+2+1=15=F Therefore, 0x0FF is assigned to PD0. The code for this application is: <quote>PD0= 0x0FF.</quote>In order to assign a particular segment as output, that particular segment direction port register is assigned 1 and the rest are assigned 0. When SW1 is pressed, the port P8.2 is set low, (P8.2==0). A condition statements can be used to set the operation of LED and segment under the control of the SW1. The commands are given for the enabling of LEDs and segments, using the port register responsible for them. All the port registers are assigned value 1 i.e. pulled high. In order to display a particular segment, only that segment is pulled low i.e. assigned value 0, others are assigned 1. The codes for setting all ports low are: <list>P0=0; - for segmentsP1.0=0; - for LED1P1.1=0; - for LED2</list><heading>Codes Explanation:</heading><heading>Assi1.c</heading><quote>#define Chip_3062x - Chip definition for full version of IAR software #include "stdio.h" #include "iom16c62.h" unsigned char dis_code [6] = { 0x0FE, 0x0FD, 0x0FB, 0x0F7, 0x0EF, 0x0DF}; </quote>Char dis_code behaves as an array and has been assigned 6 values for the 6 segments to be displayed. In order to assign the 7 segments of LED in byte form this code were used. As mentioned earlier the 7 segments were assigned to 8 bit Port P0. In order to display segment 'a' the bit assigned is 0, hence P0.0 is assigned to segment a and similarly for b,c,d,e,f ports P0.1,P0.2,P0.3,P0.4,P0.5. In order to display segment 'a', P0.0 is assigned low and rest is assigned high. <table/>Hence, total bits 8+4+2+1=15=F and 8+4+2=14=E Therefore, 0x0FE Respectively for b,c,d,e,f, ports P0.1,P0.2,P0.3,P0.4,P0.5 will be pulled low only. P0.6 and P0.7 responsible of segment 'g' and decimal point will always remain high. The byte are written in sequence order of the segments in order to make a rotation. int count; - count assigned as integer and is used as a counter for the loop displaying rotation void wait (unsigned long delay) Here, the delay variable is changed from integer to long as when high values of delay were assigned it result an error. When delay value is decreased the time, the output on the LED is displayed, became shorter, resulting the result not easily recognized by eyes. Hence, high value of delay is required in order to display the result for sufficient time to observe the results. There is also another way of changing delay, by using another loop inside delay function which carries it on for long. <quote>{ while (delay !=0)- perform the while loop by decrease the value of delay by 1 until it is 0 delay--; - decrease the value of delay by 1 before it has been decremented } void main(void) { PD0 = 0x0FF; - As mentioned earlier in working explanation, PD0 is the port P0 direction register and it set the direction of all port 0 bits to output. PD1.0 = 1; - As mentioned earlier in working explanation, PD1.0 is the Port PD1.0 direction register and it set the direction of the LED1 enable to output. PD1.1 = 1; - As mentioned earlier in working explanation PD1.1 is the Port PD1.1 direction register and it set the direction of the LED2 enable to output. PD8.2=0; - As mentioned earlier PD8.2 is the port PD8.2 direction register and it set the direction of SW1 as input. /* Set the port bits.*/ P0 = 0x0FF; - As mentioned earlier in working explanation P0 is the Port P0 register and it set all bits of port 0 as off. Hence, all the segments are turned off. P1.0 = 1; - As mentioned earlier in working explanation P1.0 is the port P1.0 register and set port 1 bit 0 high and hence, LED1 is turned off. P1.1 = 1; - As mentioned earlier in working explanation P1.1 is the port P1.1 register and set port 1 bit 0 high and hence, LED2 is turned off. Hence, there will be no output on LED2 count = 0; - variable int count is assigned value 0 to count while (1) - to perform while loop { </quote>The modifications to display result on LED1 by SW1 can be done in 2 ways: displays the result when SW1 is pressed and stop when it pressed again at the start of the program the segment rotation is displayed and when SW1 is pressed it stops the rotation until released. Here, the program codes and comments are written for 2nd method, although the 1st method can be perform just by changing "if(P8.2==1)" to "while (P8.2==0)",meaning perform the operation of rotation while SW1 is pressed. <quote> if (P8.2==1) {- perform the loop from here to display the output on LED1</quote> As mentioned earlier, SW1 is assigned to port 8 bit 2. Hence, port 8.2. Also, assigning the register of Port P8.2 to 1, set P8.2 high. If SW1 is not pressed perform the loop displaying the output on LED1. <quote> P0 = dis_code[count%6]; </quote>P0, which represents the 7 segments of LED is given the value of byte codes from dis_code. In order to choose the segment to be displayed count%6 is assigned to dis_code meaning it will display the segments in sequence order they are written. <quote> P1.0 = 0;- Set LED1 enabled on, by pulling it low, hence LED1 will display the result  P1.1 = 1; - Set LED2 off, by pulling it high, hence LED2 will not display the result</quote>LED1 represented by P1.0 is enabled by setting, the P1.0 ON. LED2 is set of by setting the port responsible for it OFF. Here, by keeping only LED1ON, will display the result on LED1 only. <quote>wait( 10000 ); - delay function</quote>Value of the delay is changed for proper display, using wait function. <quote> count++;}- to increase the count value by 1, before it has been incremented. </quote>Suppose the value of count is 2, x=count++; assigns the value 3 to x before it has been incremented. Count value is increased each time the loop is over. <quote> }- End of loop to display output on LED1 }- End main</quote><heading>Assl2i.c</heading>This program is written for the M16C/62 microcontroller embedded in the Mitsubishi M16C/62 development board. Before the lab, the program contained incomplete codes for the microcontroller to count (modulo100) he number of times push button switch SW1 is operated and display the result. LED1 represents tenth place and LED2 represents unit place. After modifications, it now displays numbers from 1 to 99 when SW1 is pressed each time. After reaching 99, the LEDs turn off when SW1 is pressed and once again when SW1 is pressed, it starts the count from 1 again. For displaying numbers from 1-9, the LED1 is switched off, as only LED2 is needed to display unit place.  <list><heading>Ports usage:</heading>P0- 8bit port which controls the 7 segments of the LEDP1.0- Port1 bit 0 to enable LED1P1.1- Port1 bit 1 to enable LED2P8.2- Port8 bit 2 for push button switch SW1</list><quote>#define Chip_3062x - Chip definition for full version of IAR software #include "stdio.h" #include "iom16c62.h" unsigned char dis_code[10] = { 0x0C0, 0x0F9, 0x0A4, 0x0B0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x98}, </quote>Define the lookup table for the LEDs in terms of bytes and helps display number '0-9' on the LEDs. Char dis_code behaves as an array and has been assigned 10 values for the 10 numbers to be displayed. In order to assign the 7 segments of LED in byte form, for each 0-9 numbers this code were used. As mentioned earlier the 7 segments were assigned to 8 bit Port P0. In order to display segment '0' the bit assigned are 0, 1,2,3,4,5, hence P0.0 is assigned for segment a and similarly for b,c,d,e,f ports P0.1,P0.2,P0.3,P0.4,P0.5. In order to display segment '0', all the ports responsible i.e. P0.0-P0.5 are assigned low and rest is assigned high. <table/>Hence, total bits 8+4=12=C and 0 Therefore, 0x0C0 is the byte for displaying '0' Respectively for 1-9, the byte codes are 0x0F9, 0x0A4, 0x0B0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x98. The byte are written in ascending sequence order of the numbers. <quote>int count; - count assigned as integer and is used as a counter for the loop displaying count void wait(unsigned int delay) - Variable Delay function to help display output for sufficient time to be recognised by eyes. { while(delay != 0) - perform the while loop by decrease the value of delay by 1 until it is 0 delay--; - decrease the value of delay by 1 before it has been decremented } void main(void) { PD0 = 0x0FF; As mentioned earlier in working explanation, PD0 is the port P0 direction register and it set the direction of all port 0 bits to output PD1.0 = 1; - As mentioned earlier in working explanation, PD1.0 is the Port PD1.0 direction register and it set the direction of the LED1 enable to output. PD1.1 = 1; - As mentioned earlier in working explanation PD1.1 is the Port PD1.1 direction register and it set the direction of the LED2 enable to output. PD8.2=0; - As mentioned earlier PD8.2 is the port PD8.2 direction register and it set the direction of SW1 as input. /* Set the port bits.*/ P0 = 0x0FF; - As mentioned earlier in working explanation P0 is the Port P0 register and it set all bits of port 0 as off. Hence, all the segments are turned off. P1.0 = 1; - As mentioned earlier in working explanation P1.0 is the port P1.0 register and set port 1 bit 0 high and hence, LED1 is turned off. P1.1 = 1; - As mentioned earlier in working explanation P1.1 is the port P1.1 register and set port 1 bit 0 high and hence, LED2 is turned off. Hence, there will be no output on LED2 while (1) - to perform while loop { if (P8.2==0) perform the loop if SW1 is pressed </quote>As mentioned earlier, SW1 is assigned to port 8 bit 2. Hence, port 8.2. Also, assigning the register of Port P8.2 to 0, sets P8.2 low. Hence, If SW1 is pressed perform the loop displaying the output on LED1. <quote> { wait(10000); -delay function if(P8.2 == 0) -perform the loop if SW1 is pressed { ++count%100; - the value of count%100 is increased after it has been incremented while(P8.2 == 0) -while function to perform if SW1 is still pressed. wait(10000);- delay function if SW1 is still pressed from the while condition } } /*for displaying 'units' place*/</quote>Here, for LED2, we do not want to display 0, the counter should start from 1 hence, the following commands were used. <quote>if (count%100==0) if the value of count%100=0 then set the port 0 for 7 segment device off. Otherwise follow else statement  P0 = 0X0FF; - Set all bit of Port 0 (all segments) off.Hence no output number is displayed when the value of count is 0.  else{ P0 = dis_code[(count%100)%10];</quote>Port 0 is given the bytes for the segment displaying numbers 0-9 through char array dis_code. The number to be displayed is operated by the value of (count%100)%10. Here, we had to use count%100 as it does not result in error when the count reaches 100. As count=100 and only count%10 is used, it gives the value 10. But we want it to start from 0 again. Hence, (count%100)%10 is used instead of count%10. <quote>P1.1 = 0; - LED2 is set low and hence will be on wait(100); - delay function to display the result more sufficient time P1.1 = 1; - Set LED2 off } /*for Displaying 'tenth' place*/  if (count%100<10) - if the value of count%100<10 then set the port P0 off, as we don't need LED1 ON to display numbers from 1-9. It is ON only when the count reaches 10 P0 = 0x0FF; - Set all bit of Port 0 (all segments) off.Hence no output number is displayed when the value of count is 0.  else{ - if the value of count%100 is not less than 10 then perform the following P0 = dis_code[(count%100)/10]; Port 0 is given the bytes for the segment displaying numbers 0-9 through char array dis_code. The number to be displayed is operated by the value of (count%100)/10. P1.0 = 0; - LED1 is set low and hence will be on wait(100); - delay function to display the result more sufficient time P1.0 = 1; - Set LED1 off }End else condition for displaying tenth place }End if condition of when SW1 is pressed }- End main </quote><heading>Observations:</heading>When the programs were executed the results obtained was as expected. For the first assignment, there are two methods were used to show how SW1 is used to control the rotation in 2 different ways. The result obtained by using the 1 st method was when SW1 was pressed only then the rotation started and when released it stopped. Under the 2 nd method the rotation started when the program was executed, but when SW1 is pressed it stops the rotation and when pressed again it starts the rotation. In both methods, the delay function was observed and it affected the time for which the output is displayed. If the value of delay is more the more time the output is displayed meaning it gives sufficient time for the eyes to recognize the changes. For the 2 nd assignment, when the program was executed it turned off both LEDs and when SW1 is pressed it, LED2 displays 0. Each time it is then pressed it shows the count from 0-99 on both LEDs. Though LED1 is set off when the count is under 10. When count reaches 100 it turns off both LEDs and when pressed again it starts the count from 0-99 again. <heading>Conclusion:</heading>From my observations, the program codes functioned as required and therefore I met all the requirement of the tasks. 