<heading>Question 1</heading><heading>Aim </heading>To define a function that returns the maximum of three numbers. <heading>Version 1</heading><heading>Code</heading> FORMULA  <heading>Explanation</heading>The function max3 is defined as having 3 arguments - a, b, and c. If a is the largest, then return a. If b is the largest, then return b. If c is the largest, then return c. In the case of error, return 0. <heading>Test</heading> FORMULA  <heading>Conclusions</heading>Although the first three tests were successful, the fourth was not. The reason for this was that when using the strictly greater than sign, neither of the threes is the maximum. We can correct this by making the signs greater than or equal to. <heading>Version 2</heading><heading>Code</heading> FORMULA  <heading>Test</heading> FORMULA  <heading>Conclusion</heading>This function now performs its task correctly. <heading>Question 2</heading><heading>Aim</heading>To create a recursive function that uses Euclid's algorithm to find the greatest common divisor (GCD) of three positive integers. <heading>Version 1</heading><heading>Code</heading> FORMULA  <heading>Explanation</heading>Euclid's algorithm is based on the fact that GCD(a,b) = GCD(b,r) where r is the remainder of a and b. This means that you can create iterations whereby a becomes b and b becomes r until b hits 0. The recurring function I created tests to see whether b has reached 0. If it has, it returns a, which is the GCD. If it has not, it recurs the function with b and the remainder of a and b. This will not create an infinite loop as Euclid proved that b will reach 0 in a finite number of iterations. <heading>Test</heading> FORMULA  <heading>Conclusion</heading>This function performs its task correctly. <heading>Version 2</heading><heading>Code</heading> FORMULA  <heading>Test</heading> FORMULA  <heading>Conclusion</heading>This function performs its task correctly. <heading>Question 3</heading><heading>Aim</heading>To create a function to return the GCD of three integer arguments. <heading>Version 1</heading><heading>Code</heading> FORMULA  <heading>Explanation</heading>The min3 function is as the max3 function in question 1, but with the signs reversed. It is needed for the gcd3 function. The gcd function is called initially. It checks that the three values are greater than 0, then finds the smallest of these three values and calls the function gcd3a with this value and the three initial arguments. The recurring function gcd3a has four arguments. It has the three initial values that it will find the GCD of, and the divisor, d. This variable d will eventually contain the GCD. We know that this won't be larger than the smallest of the three integers, so it starts at the minimum of the three. If d divides into all three integers with no remainder, then it is the true GCD. If it doesn't then it recalls the function with d decreased by 1. It will not enter into an infinite loop as when d hits 1 it will divide into the other three integers with no remainder whatever they are. d will approach 1 as it has to be greater or equal to 1 initially because the numbers that it is the minimum of are. <heading>Test</heading> FORMULA  <heading>Conclusion</heading>This function performs its task correctly. <heading>Question 4</heading><heading>Aim</heading>To create a function that returns whether or not a given integer is prime. <heading>Version 1 </heading><heading>Code</heading> FORMULA  <heading>Explanation</heading>The non-recurring function 'prime' is called first. This has one parameter, x, which is the integer that will be tested. If x is equal to 0, 1 or -1, it is not a prime number, so the function can return false. If x is negative, then the function prim1 will be called with negated (i.e. made positive) values of x. If it is an integer that is greater than 1, prime1 is called with x. The recurring function prime1 has 2 parameters: d, a temporary number that will decrease, and x, the positive integer that is being tested. At the start, d = x. The function divides the x by d. If there is no remainder, then x cannot be prime, so the value of false is returned. If there is a remainder, then the process is run again with d decreased by 1. If d gets down to 2 without ever creating a zero remainder when x is divided by it, then x is a prime number and a value of true is returned. It will never enter an infinite loop, as d starts as a positive integer that is greater than 1 and decreases while it is greater than 2. This means that it must reach 2 in a finite number of iterations. <heading>Test</heading> FORMULA  <heading>Conclusion</heading>This function performs its task correctly. <heading>Version 2 </heading><heading>Code</heading> FORMULA  <heading>Test</heading> FORMULA  <heading>Conclusion</heading>This function performs its task correctly. If you think about it, however, it is doing a lot more processing than it needs. If we enter "prime(16);;", it starts by seeing whether 15 will divide into 16, then 14 etc. In reality, there can be no integers that divide exactly into 16 that are above 16/2 = 8. Therefore, we only need do half the iterations. I will make a version 3 that takes this into account. <heading>Version 3 </heading><heading>Code</heading> FORMULA  <heading>Explanation</heading>This is much as before, but with the divisor starting at half of x rather than at x. For more information see Version 2's conclusion. The other change that was implemented was that the specific case of when x = 2, 3, -2 or -3 needed to be added as patterns. This is because using integer arithmetic; all four of these values halve to make 1 or - 1. If we were to let prime1 run with this it will see that x divides into 1 and say that it isn't a prime number. <heading>Test</heading> FORMULA  <heading>Conclusion</heading>This function performs its task correctly. <heading>Self-Reflection Task</heading>After writing all of the functions needed for this set of tasks, I had a lecture about patterns. I realised that a few of my functions could be neatened using these, so I have added a more concise second version to some of the working functions. Through doing this work, I appreciate more fully how recurring functions as well as functional programming in general works. I have realised the importance of the order of the code - you can't refer to a function in a piece of code unless you've declared said function previously. I also realised that when working with integers, it is necessary to think about integer arithmetic, for example that 3/2 = 1. This is something I'm not used to doing, so it comes as a bit of a shock. I did encounter difficulties using Xemacs and Unix themselves; it took a while to get used to not performing copy and paste operations using MS Windows keyboard shortcuts, and it was odd not having the CTRL-ALT-DEL option when it crashed. As an afterthought, the prime number function in question 4 could be made even more economical by using the square root of x as the initial value of d, rather than x / 2. 