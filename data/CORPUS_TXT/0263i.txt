<heading>Resource Management :</heading>Initially the plan for the second part of the project was to complete the design totally then begin implementation, iterating the analysis, design and implementation as required. Having completed an initial analysis for part one of the project, we felt it would be preferable to do a rough design then to begin the basic implementation, effectively running design and implementation in parallel but with design a few steps ahead. The critical path analysis can be seen below. The analyses, designs and implementations are constantly iterated in parallel throughout the project, but both paths (GUI and non-GUI) are equal in length. <figure/>We felt that our initial staff estimates would have given us a very large design team for the size of task, possibly over-complicating the design process, and we were keen to begin the implementation as quickly as possible as we were aware it was the largest task which was likely to take the most time. This meant that we had to redistribute effort and people accordingly. The initial staff plan was given in part one of the project and the final revised version can be seen below. <table/>We iterated the analysis and design as implementation progressed, with team members swapping between roles as they became free. For example, Brian McWilliams had been heavily involved with analysis in part one of the project so was allocated tasks in the first stages of implementation then, when these were completed, was able to swap to iterating the analysis documents. We aimed to make the work distribution as fair as possible, while aiming for optimal use of each team member's time - this included making use of their existing skills, such as using those who had been most involved with analysis in part one to iterate the analysis in part two. The initial effort and schedule estimates were included in part one of the project and the final revised version can be seen below, split between weeks and activities. <table/><heading>Source Code Control :</heading>For the majority of the project (i.e. until integration testing began), our source code was split into two basic parts - the GUI code and the rest of the code - which were stored physically separately by two different group members. During integration testing, all the code was copied into a new area which was used as the central repository. GUI: As only one group member (Richard Thompson) worked on the code, source code control was relatively simple. He stored the code on his computer, keeping regular backups and creating new code versions when significant code alterations were required, so that he could revert to earlier versions if the modifications did not work correctly. He made sure he notified the other team members if he wanted to make changes to how the GUI interfaced with the rest of the program. Beyond that (i.e. alterations to how the GUI functioned) however, he simply kept track of the changes himself as the rest of the team did not need to know how it worked, only what interface it would present to the rest of the program. <heading>Remaining Code :</heading>The chief implementer - Kisan Kansagra - was put in charge of looking after the central code repository and ensuring that all stored program versions were consistent. All code which was not directly related to the GUI was stored in a password protected folder in his public area on the DCS machines. All team members were notified of the password so that they could view the code as required. Whenever team members created new code modules or altered existing ones, they either informed Kisan or placed the new/altered files in the repository with a different file name, so that previous versions were not overwritten and lost. Kisan made sure each group member was aware of such additions and alterations so that everyone was aware which version they should be working from. <heading>Installing, Compiling and Executing :</heading>In order to compile the code initially, the code controller first ensured that all relevant files were part of the race package and placed them all in a single race folder. He then navigated to this folder at a command prompt and typed "javac *.java" to compile all the Java files within the folder and so create the required .class files. The original Java code files were then copied to another folder (code) to separate the compiled from the uncompiled code. These two folders (race and code) were then put together in a zipped folder. In order to install the program, the user simply needs to copy the zipped folder to the area they wish to install it in, then unzip folder there. The program will then be installed in this location and can be run by navigating to the folder at a command prompt and typing "java race.Report <filename>" for the command line version or "java race.Gui" for the graphical version. 