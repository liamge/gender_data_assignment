<abstract><heading>Summary</heading>The mini micro project was the way to put into the practice what we learned in our module. The project which was given to us was the Speaking clock. The speaking clock is the project that uses most of the concepts that we have learned in our module COMPUTER STRUCTURE AND ORGRANISATIONS. The project was an intense task to complete, as it used most of the concepts of the Digital Input and Output. The purpose of this project was to learn how to control hardware devices through software. The main objective of the project was to develop a system that produced the most acceptable spoken time when the key is pressed. The program was written in C language. In the time given of 4 labs we were able to complete the project and also tried to add few functions that enhanced the speaking of the clock. </abstract><heading>Introduction</heading>The objective of the project "SPEAKING CLOCK" was to develop a system that produces the most acceptable spoken time when a key is pressed on the terminal. The time would be spoken by using a combination of allophones to create a string for the sound. As we already had the knowledge as how most of the VIA register works, it was not very difficult for both of us to understand as how to go about in the speaking clock project. The software labs done earlier helped both of us as where to implement different things in the project .We were able to clear most of your concepts in the digital input and output topic while doing the project. This particular project required software programming only. The project comprised the use of SWET and a speaker. After the completion of the code, it was loaded on to the SWET, which was connected to the speaker and then executed. Before doing this project we didn't had any idea of the C Language but still with the help of lab assistants we were able to complete our project within the 4 provided labs. <heading>Analysis of system specification, design details</heading>In this segment, we have presented details of the working of every section of our final code. <heading>Specification</heading>You should be able to input the initial time in hours minutes and seconds HH:MM:SS. Acceptable spoken time must be heard when a key is pressed on the terminal. The time should increment like a digital clock and it should be shown on the terminal. <heading>Design of Sub-systems</heading>In order to use the Versatile Interface Adapter we had to define pointers to the registers, which we wanted to use in the program. We set port B Data Direction Register (DDRB) to 1 so that it carries an output signal. Port A DDRB is set to 0 so that it can carries an input values. Port B Output Data Register (ORB) is used to output the time from the allophones used. We initialised the Peripheral Control Register (PCR) to 1 so that when the CA1 interrupt flag (IFR1) will be set by a positive transition (low to high) on the CA1 pin. By setting Interrupt Flag Register (IFR) bit, it can cause an interrupt if the corresponding bit in Interrupt Enable Register (IER) is set. We have written a value to Interrupt Enable Register so to that the Timer T1 Interrupt is enabled (bit 6) and Set/Clear Control (bit 7) is set so that each data bus bit is set to logic 1. We needed a Timer so that produced an evenly spaced interrupts that was continuous. We set the Auxiliary Control Register (bit 6) to logic 1 so that T1 is in free-running mode and generates continuous interrupts. Refer to APPENDIX A. <heading>Design & System implementation</heading><heading>THE ARRAY FOR THE SOUND</heading>The main requirement of the project was the speaking of the accurate time by the clock. The first key thing that was done in the project was making different sounds by taking right values from the 64 allophones sounds that were provided in the lab sheets. We made a two dimensional array in which we stored all the numeric values that were required during the speaking of the clock. The size of the 2-d array was 24 by 14. Each sound of the numeric digit 0 to 20 was given in the array with required pauses that were one of the second argument of the speak() function. <quote>{13, 200, 46, 400, 7, 100, 11, 300, 17, 25, 19, 200, 0, 0}, /* 20 */ {40, 300, 52, 50, 17, 25, 19, 200, 0, 0, 0, 0, 0, 0}, /* 30 */ {40, 1000, 58, 3000, 17, 25, 19, 200, 0, 0, 0, 0, 0, 0}, /* 40 */ {40, 100, 12, 50, 40, 300, 17, 25, 19, 200, 0, 0, 0, 0} /* 50 */</quote>The last three elements of the array were build to produce the sound for the 30,40, 50 number. Since they were used with the combination of other elements when the time was greater then 30. As if the time entered on the terminal was 31 then the speak function carried the parameters for the two digit one was 30 and the other array element which was sent as a parameter was to produce the sound for the digit 1.So any time that was above 20 used the same pattern for all minutes as well as seconds. <quote>delay( int noof_delay ) { volatile int i; for (i=0; i<noof_delay; i++) ; /* a for loop which does nothing */ }</quote>Different values of the pauses was provided in the array according to the requirement .The implementation of the pauses in the program was not done with the use of the allophone codes that were provided, But was achieved by the use of another function that was the delay() function. The delay() function took a integer type number as the parameter and then an empty loop was executed by the use of for loop structure which was used so as to bring a delay in different sounds that were to be produced by the clock. Less pauses where given when the values for 30, 40 and 50 were given in the array as the next digit that has to spoken by the clock didn't needed much of the pause in it as saying "thirty five" should not have a big pause in between "thirty" and "five" speaking by the clock. Proper delays were required between each allophone value as if the pause provided was small then there was no distinction between the words as they two sounds overlapped with each other as the process within the program was very fast so delay were very essential thing to be provided in every element of the array. Giving proper delays in the elements of the array took us lot of time as it was not exactly same for all the words some needed more some less. <heading>INPUT FROM THE USER</heading><quote>prf("\nEnter hours (00): "); hour1 = term_in();</quote>For the purpose of reading in a value from the keyboard, we were required to make use of a function 'term_in()' which when called would return the 7-bit ASCII character code. A message was printed out prompting the user to key in the digit for the hours for example. The method 'term_in()' was then called and the returned value stored in a variable ASCII 1 <quote>prf("%d", minutes2 - 48);</quote>The value which was given on the terminal was the ASCII value so it was changed to the normal form by subtracting 48 from it .As the ASCII value for the character 0 is 48 and the values for other numbers are in continuity like 1 has the value 49, 2 as 50. So to get the value 1, we subtracted 48 from it and the first input digit was obtained. In the same way all the input are taken and evaluated in the program. <quote> minutes = ((minutes1-48)*10) + (minutes2-48);</quote>On the terminal the value that was printed was not the ASCII value but was the value that was obtained after subtracting 48 from it. Then one final variable for each of the hrs, min and second was used which combined the two digit and made into a one value and that value was then used further for the speaking of the clock. <heading>OTHER FUNCTIONS FOR SPEAKING OF THE CLOCK</heading><quote>void thetimeis() { speak(33, 2000); delay(3000); speak(13, 400); speak(6, 1000); speak(16, 500); delay(3000); speak(12, 600); speak(38, 3500); delay(2000); }</quote>The first function used is the thetimeis(). This is the first function, which is called while the speaking of the clock. This function passes different parameters to the speak() function which is used to produce the sound of "the time is" before the time is spoken by the clock. There is also the use of the function delay() in the function so as to bring distinction in the three words. The function delay() runs an empty loop till the parameter value. <quote>void and() { speak(26, 800); speak(11, 200); speak(21, 700); }</quote>The next function which is used is the and() function which in the same way passes the parameter to the speak() function as the timeis() function and the word "and" is spoken by the clock. The delay() function is again used in this function. <quote>void sayseconds() { speak(43, 300); speak(7, 50); speak(8, 700); speak(24, 200); speak(44, 400); speak(43, 1000); }</quote>The third function used is the saysecond() function .The function when called in the loop will say the "seconds".The function called the function speak() by giving different parameters which were taken from the 64 allophones sounds that was provided. <quote>void oclock() { speak(30, 200); speak(8, 300); speak(45, 300); speak(24, 200); speak(8, 500); }</quote>The fourth function which is used is the oclock() function which when called in the loop will call the function speak to produce the sound . <heading>THE TIME CONTROLLER IN THE PROGRAM</heading>The timecontrol() function is the function which was called when an interrupt is flagged in the IFR .It responded to the interrupt. This function is used to print the running time which is input by the clock until the program is running and the value of minutes, seconds and hours will keep on changing as the time is changing. There many conditions which are considered in this function as when the value of seconds reaches 60 then the value of seconds is initialised as 0 as the value of minutes is incremented by 1 .If the value of minutes reaches 60 then the value of hours is incremented by 1 and the minutes value to 0. When we have the value of hours as 13 it is changed to 1 .The last thing that is done in the function was the printing the right values on the terminal window as if the value of hours is less then 10 the it will printed in the format of "0:"then the value, same format is used for the printing of the values for the minutes and seconds. <heading>SPEAK FUNCTION</heading><quote>void speak(int sound, int delayTime) { if (!(sound == 0 || delayTime == 0)) { while (!(*VIA_IFR & 2)) ; *VIA_ORB = 64 + sound; *VIA_ORB = sound; delay(delayTime); *VIA_ORB = 64; *VIA_ORB = 0; } clear = *VIA_ORA; }</quote>The function which was used in the program for the speaking of the clock was the speak(int sound, int delayTime) function .The function took 2 parameters one was used for the sound while the other was used to give a pause in the function by the calling of another function which was the delay function which provided pauses in the program whenever required. There was the use of the if and while statement in order to get the function work appropriately .The if statement was if (!(sound == 0 || delayTime == 0)) .The control entered in the function only when the value of sound was not zero or the value for delayTime was zero. The next condition that was implemented in the function was the while statement which was checked when the if statement was true .The condition for the while statement was while (!(*VIA_IFR & 2)) ; .When the while condition was true the control entered the loop and the value of sound was given to the register and after that the other parameter was passed to the delay() function which produced the delay and then control was back again and the while statement executed the condition of !(*VIA_IFR &2)). <heading>PARAMETERS FOR THE SPEAK FUNCTION</heading>The next thing to be done was sending parameters after checking the value of the time input on the terminal. Many different if statements are implemented in the programming for checking the range of the time input by the user as weather it lies between 10 to 20 or 20 to 30 and so on .By checking the right value the parameters were sent to the speak () function . If the value of minutes or seconds was greater then 20 then the function speak() was called two times, because at that stage two distinct words were required to be spoken by the clock .For example if the minutes input by the user was 22 then when the first time the speak() function is called , parameter for speaking twenty was given .Then the other value was checked by subtracting 20 from input .And then sending that value array index to the function .Since the array index was 23x14 so a for loop was used to send parameter to the speak function as it will take values from that array index starting from the first and 14 different values were send to the function when checking the range in the programming. The same programming was implemented for the seconds as well as they also needed to be considered in the same way as minutes in the programming. Through out the programming the minutes and seconds programming carried the same logic with them. When the clock spoke the minutes pause was provided and the and() function was called at that time. Everywhere in the programming pauses are provided by calling of the delay() function by passing suitable parameters to the function as per requirement. When we are sending the parameters, the speak() function takes two parameter one is the sound value and other is the delay time. In the 2-d array which is used each entry in it contains a pause in it which is passed together with the sound and once the value is sent to ORB then the function delay is called by sending the second parameter to that function giving delays in the speaking of the clock was crucial thing and required lot of attention to be done correctly with loads of checking. <heading>System implementation and testing</heading>Implementing the task was challenging and a lot of thought had to be put into the program of how the system will all function together once all the method had been implemented. After compiling and re-compiling the program to fix errors, the program seemed to work as expected. We minimised the risk of causing error in the program by implementing the code so that methods didn't get overloaded. Although we still needed to carry out rigorous testing to see if there were any faults with the program, we were satisfied with the system at this stage. <heading>Testing</heading>One of the main tests that we carried out was the testing of the allophones. This was a continuous test throughout the project. We need to be sure that the allophones that were stringed together were outputting clear times so that a people can understand what the time was. We changed some of the allophones to try and make the time clearer. Trial and error was the best way to get a sound that was good enough. As part of the specification the time must be clear enough to be understood by individuals. Although numbers seemed to be easier to plug string together from the allophones, there were a lot more numbers than words. We found that words were more difficult to string together from the allophones. We used the same technique as trial an error to make the words sound clearer. A lot of time was spent on working out how to string these allophones together to create a number and a word. We split the task up between ourselves to try and work quickly and efficiently through the task. When we entered the time value on the console, it wasn't what we expected to see. We intended to enter 09:00:00 on the console. The character 0 appeared as 48. 48 is the decimal value of the ASCII character set for the character 0. To solve this problem we had to subtract 48 from the character that were typed in from the keyboard. But we need to make sure that when the first value of HH:MM:SS needed to be subtracted by 48 and then multiply it by 10 and then add the second value to it to get the value of the HH:MM:SS. For example if we inputted 12:00:00 in the console then what the program does is to translate the decimal value of 1 to be 1 and multiply it by 10. Same producer happens when you press 2 on the keyboard, but the value does not get multiplied. Therefore on the console we get 12 because 10 + 2 = 12. We carried out test for the interrupt pulses that controlled the accuracy of time in seconds. We managed to fine-tune the pulses as accurate as we believe it could have been. We set a time for example 10:59:00 to see if the clock would change to 11:00:00 when seconds get greater than 59. This part of the test to be working and we knew that the clock was working fine because in our program we have set conditions to deal with these type of scenarios. <heading>Analysis and discussion of system performance</heading>System Requirement You should be able to input the initial time in hours minutes and seconds HH:MM:SS. Outcome The time can be set at via the keyboard at the start of the program on the terminal window. We found that you can enter invalid time on the terminal. This caused the programme to stop working. This problem can be resolved in future by having a condition in the program that only lets you input the time in a certain format. System Requirement Acceptable spoken time must be heard when a key is pressed on the terminal. Outcome When you press the enter key the time is spoken at the current time. The time was recited at moderate speed by the loud speaker. The time was heard clearly. System Requirement The time should increment like a digital clock and it should be shown on the terminal. Outcome The time was updated on the terminal window every second. Because we used the 'free running' mode Timer 1, it produces a continuous series of evenly spaced interrupts that is ideal for accurate time. Also because the frequency is not affected by the variations in the processor interrupts, it's still able to keep track of the time when you press a key on the keyboard to get the time. Although we had to use an estimate for the Timer 1 it was still accurate to 1 sec. An improvement with the accuracy of the time can be made here if we used an oscilloscope to find the number of clock cycles per second. <heading>Problems encountered</heading>When you enter a time on the terminal the format should be HH:MM:SS. The problem was that if you had a value that was less than 10, then a 0 is required in front of the number to make it an acceptable format. We had to place a condition so that if the number was less than 10 then place a 0 in front of the number. <heading>Technical Difficulties</heading>When stringed each allophone together we had to test it to see if it was heard clearly. This testing took a lot of valuable time because compiling the code and loading it took a lot of time. To speed up the process we disable the Timer 1. This made was enabled us to carry out test quicker as loading time was shorten. Although time in the lab was limited so we had to work relatively quickly through the tasks and this caused mistake to occur like missing semi-colons or parentheses. These were fixed eventually when we looked back through the program, but it did stop us from progressing further. We liked to have written a method that fixed the problem of being able to set incorrect times. Because we did not have enough time in the lab we were not able to carry this task out. <heading>Future Extensions</heading>There could be an optional continuous spoken time, which would speak every minute or hour. A stopwatch could be implemented to time how long people have been working at the terminal. There could be a feature that can also take account of the date. This can be used to implement the transition from summer to wintertime. A reminder system can be implanted to remind people of important events like meetings. This implementation can be done by taking the time input from the user when it wants the reminder to be set. When the program is running and the program encounter that time by the use of if statement then other function can be called which produces a different sound which can say anything as the requirements. The time zones around the world could be implemented to show the time in different countries. This implementation can be achieved by making one more variable that takes the input from the user as with respect to the current which countries time it want the clock to speak by giving choose of different countries. Then by checking that input the value from the current time can be added or subtracted and then the value to be sent to the other function. The need of a speaking clock The system can be used to help people of all ages. A speaking clock can help primary school children to tell the time. When they press the 'enter' key on the keyboard the time will be spoken and this will help children how to tell the time and help them with recognising numbers. The blind would benefit greatly by this because at least they can now keep track of the time without having to rely on other people. <heading>The need of a speaking clock</heading>The system can be used to help people of all ages. A speaking clock can help primary school children to tell the time. When they press the 'enter' key on the keyboard the time will be spoken and this will help children how to tell the time and help them with recognising numbers. The blind would benefit greatly by this because at least they can now keep track of the time without having to rely on other people. <heading>Conclusions</heading>We managed to complete the project within the time given and achieved to design the system to the specification. Good time management skills enabled us to complete the project on time. We were able to solve problems encountered during the implementation of speaking clock because we made sure that we tested parts of the code rigorously. We learned a lot from the outcome of the project and how powerful software is in controlling hardware devices. Writing the report has also given us greater knowledge of the VIA and how I/O devices operate. Working as a team we have learned a lot from each other and the experience gained will help us to work in teams in the future better. 