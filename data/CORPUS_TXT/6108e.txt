<heading>Introduction</heading><picture/><abstract><heading>Abstract</heading>The Sony Ericsson S710a Mobile Telephone, part of the S700 family, is part of Sony Ericsson's new generation of mobile phones, equipped to the latest standards, to be launched in the United States and European markets, including the United Kingdom. Featuring a 1.3 Megapixel digital camera, Bluetooth wireless interface, and a memory expansion slot (with which a Sony Memory Stick duo can be used to increase available system memory for storage). The telephone features a large, high-resolution colour screen and 32MB main memory. A full specification of the unit can be found on the Sony Ericsson web page referenced at the end of this report [1]. </abstract><heading>Project Brief & Overview</heading>For the new Sony Ericsson S710a, part of the launch of the new handset is the design and development of software for the product. One such piece of software to be produced is an 'Appointment Module' designed to work in connection with the SIM card, address book, and other functionality already present in the phone's bundled software. Sony Ericsson desire that this appointment module should allow users to enter appointments into a calendar interface, stored in the handset, which will hold corresponding contact details of involved parties with the appointments, in order that when an appointment is due, each person concerned with the appointment may be issued a text message reminder automatically by the software. This report is concerned with how the requirements of Sony Ericsson were met with the design of such an appointment module, codenamed "CellCal" for the duration of this project. Several stages in its design were undertaken sequentially in order to produce a well-designed and appropriate solution: <list>Analysis of the structure of the handset's software, inputs, outputs and interactions through the use of modelling techniques (UML - Unified Modelling Language) to produce a series of diagrams to visualise the structure of the telephone and it's interaction with the proposed CellCal application. These can be found in section 2 of the report.Design of an appropriate system in an object-oriented programming language- with justified design choices to be found in section 3 of the report.Conclusions and recommendations for further development, along with associated information, in section 4.</list><heading>Design of the system in UML</heading><heading>Introduction</heading>The design of an appropriate solution to the problem presented by the client, Sony Ericsson, requires the use of an object-oriented approach to coding a suitable application. Use of an OO language allows for better interaction between the separate modules of the phone, greater flexibility, easier debugging, and an is ideally suited to the problem presented. The need to store multiple appointments in a calendar, with associated contacts, already lends itself to an object-oriented design - with individual Appointments and Contacts form base classes themselves- each contact or appointment has a certain number of properties, or 'attributes', such as Name, Date or Venue, which are standard for every instance of a contact or appointment, but which multiple instances may be required with different properties in those attributes, for example, different contacts. These classes can be accurately modelled in an object-oriented language, but before this can be done, it is important to lay the foundations of this modelling by designing the system in Unified Modelling Language (UML). The following pages contain three diagrams that attempt to model the proposed CellCal system in UML - (i) A Use Case diagram that illustrates the interaction of the user and components of the phone handset to perform different actions or 'use-cases'; (ii) a Class Diagram that expresses the design of the system in terms of individual classes to be implemented and their interactions with eachother; and (iii) Interaction Diagrams consisting of a Sequence and Collaboration diagram to represent the communication between classes as modelled in (ii). Java 2 Standard Edition (J2SE) was selected as the programming language in which to implement the system. It was selected for the following reasons: It is a true object-oriented language ideally suited to building a appointment system with distinct types and properties, that can be modelled as classes and attributes; The native support of Java on the Sony Ericsson S710a platform (implemented in the form of Java Mobile Edition - JME). <heading>Use Case Diagram</heading>The following UML diagram represents the first stage in a well-planned design- that of Use-Case. The diagram represents the interactions of the user(s) (in this case, only one, that of the Phone User) represented as an Actor to the left of the diagram, with the mobile handset as a whole. Each oval symbolises a 'use-case', that is, a possible action that the user of the phone may take, or functionality they may use, or the interactions between constituent elements of the handset in terms of functionality used by each part. Each of the key actions that can be taken by the user are represented to the left. These actions interact with each other using functionality provided by the handset - which in turn makes use of the functionality of the SIM card which stores the Address Book data, and handles communication with the mobile network. Note that the auxiliary functionality denoted with * represents functions such as MP3 playback, calculator, games which are, though valid use cases, not relevant to the design of the CellCal application. <figure/><heading>Class Diagrams</heading>The second phase of the development of the CellCal application is to express the design of the module in terms of classes and attributes, and their relationships, using a UML class diagram. The class diagram shows each user-defined class as a separate rectangle on the diagram. The name of each class is stated in the top box, the middle box gives the names of the attributes associated with that class, and the bottom box gives the methods available in that class. <figure/>The attributes given with each class represent the data that will be stored as variables or constants for each class - for example, in the Contact class, information about a contact's name, telephone number and email address need to be kept - as such, three distinct attributes are defined to store each of these values. Each attribute is suffixed with the data type, defining the type of information that can be stored by that attribute - only two are used in the design for the CellCal system - String (which can hold a row of alphanumeric characters) and Date (which holds a Gregorian calendar date), though Java 2 supports a number of other data types. The bottom box gives the methods associate with the class - these are the functions, calls or procedures that trigger an action within the system, interacting with other classes to produce an output as a result of user action or background processes. Each attribute and method is given a visibility definition - this determines how a method or attribute can be accessed outside of its own class or package. The three visibility types are public, private and protected, and they are denoted on the diagram by- a coloured brick for a public method or attribute, and a coloured brick with a padlock for a private method or attribute. No protected methods or attributes are defined in this project. Public visibility specifies that a method or attribute can be used or altered by an associated class, whereas private visibility specifies that an attribute or method's features can only be used by the class to which it belongs. The relationships between classes are shown on the diagram by the arrows been objects - the description of the relationship is given in the diagram's annotations- for instance, the Address Book class will be used to define a vector or array to hold contact records. Multiplicity is defined through the numbering at each end of the lines - so in the case of the Contact class, zero or more contacts can be held, but there must only ever be one Address Book holding those zero or more contacts in existence at any given time. The diamond arrowheads on these relationships show the type of aggregation between classes. A black diamond head shows that the classes are linked by a composition aggregation - that is, a linked class is a part of the whole of the class with which it is linked, and will cease to exist should the class it is linked to be deleted - so, for instance, Contacts cannot exist outside of the Address Book. A white diamond illustrates shared aggregation - whereby a class can exist separately and numerous instances could exist for each instance of the class it is linked to. So in the case of Contact-Appointment class relationships, individual Contacts can exist without being a part of an appointment, and an appointment can concern a number of different contacts, such as a meeting with a group of colleagues. <heading>Interaction Diagrams</heading><heading>Sequence Diagrams</heading>The following Sequence Diagrams demonstrate how the objects defined in the system interact, in turn, to produce desired functionality. Diagrams for major functionality, adding and editing appointments, are presented below. Given in the top left of the diagram is the Actor representing the user of the phone. Alongside this are the major objects that the system will interact with to produce the functionality the diagram is illustrating. Starting from the left-hand side, each arrow, numbered and labelled (beginning with Add Appointment - the user function triggering the sequence) represents a sychronous call to the object with which the arrowhead touches- that is, a single-threaded procedure executed within the system. It waits for the results of its actions and return calls to pass messages back through the system. <figure/>The arrows to the far right of the diagram (alighned with the Appointment object) which return on themselves represent self-delegation calls, whereby a particular object will utilise functionality within itself to accomplish a task (for example, making sure required fields such as Name are not left blank). The dotted lines represent return calls, passing messages back through the system, culminating, in the case of the Add Appointment functionality, in the user being informed whether their appointment details were entered successfully or not. Return calls, given by the dotted lines, represent a return from an earlier message sent through the sytem, so in the case of the Edit Appointment sequence, return call 8 confirms whether an appointment's changes where sucessfully applied in order to provide the user feedback. <figure/><heading>Collaboration Diagrams</heading>The second type of interaction diagram to be employed in the desing of the CellCal system in UML is a Collaboration Diagram. These are generated in conjunction with sequence diagrams to identify the objects in the system which play a role in interaction and to lay them out to visualise that interaction. <figure/>Each object is displayed as a rectangle, as in the Sequence diagram. The flow of information is indicated by the arrows, with events numbered and annotated. Self-delegations are represented by the semicircles, indicating the flow of information within the object itself. <heading>Prototype</heading><heading>Design Decisions</heading>Following the design and graphical modelling of the system using UML techniques, the system was implemented in J2SE using the open-source NetBeans integrated Java development environment [2]. A justification for the major design decisions can be found listed here, and sample code to accompany the text can be found in section 3.2 below. In accordance with the class diagram in figure. 3, four classes were designed to represent the objects Contact, Address Book, Appointment, and Events Calendar. Each of these classes specified the attribute and methods specific to the operation of that object. Vectors were to be implemented as part of the EventsCalendar and AddressBook classes, to hold the 'records' defined in the Contact and Event classes. Java 2 SE's built-in Calendar class and associated methods could be used to implement the calendar, and the scheduling of reminders. A JFrame class was added to provision for the building of the graphical user interface for Appointments, to add, remove and edit appointments. <heading>Sample Code</heading>For the sake of brevity, a full unit listing of the source code for the project has been omitted from this report. However, a full electronic version of all source files, in .java format for source classes and .jar bytecode compiled format can be found attached to this document. <heading>Conclusions and Recommendations</heading><heading>Conclusion</heading>Designing, developing, coding and testing the prototype CellCal appointment module for the Sony Ericsson S710a proved to be a difficult prospect initially- the key to success was in the breaking down of the large project (as described in the initial overview) into smaller, more manageable section. The project lent itself ideally to object-oriented design, and the analysis of the project using UML techniques to model each part of the larger system into separate classes, with associated member attributes, contributed greatly to simplifying the design and making its development easier and more logical. Assumptions were made about the scenario and the system. Firstly, it was assumed that only a single telephone number (presumably mobile, for the the purpose of sending SMS reminders) would be stored for each contact. It was also assumed a set period of time before an appointment would define when an SMS reminder would be send - an extension would be allowing a user-defined time period. Further extensions to the system primarily concerns moving from a prototype, which we currently have, to a first-version which can be deployed on the S710a mobile telephone's java platform. This will require the code to be ported to the Java 2 Mobile Edition API (J2ME), upon which the java support on the mobile platform is founded. The J2ME virtual machine is a cut-down version of the Java platform used to develop for a personal computer, and as such features a far more limited variety of built-in classes and functions. 