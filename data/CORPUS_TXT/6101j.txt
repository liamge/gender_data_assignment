<abstract><heading>Abstract</heading>The principle aim of the project is to develop a PDA application with which a user can see information regarding the geography of the area they are in. More specifically, the project will focus on displaying an accurate drawing of the skyline and labelling any hills that feature. Alongside the PDA application there will be a PC application, with which the user can select the area that they intend to use the PDA in, and have the relevant data made available to the PDA. This interim report is to discuss progress made thus far, and also to amend and create plans for the remainder of the project period. </abstract><heading>Introduction to the Project and Specification</heading>There exist programs for viewing maps in 3D on a computer. Examples are Google Earth [1], ESRI ArcGIS [2], and Memory-Map [3]. <picture/><picture/>There also exist programs for viewing maps and geographic features on a PDA. Examples are ESRI ArcPad [4] and Mobile Memory Map [3]. <picture/><picture/>Both of these examples, and indeed all other existing products I have looked at, will only show the world in plan, as a map. My project, therefore, is to do what, it seems, has not been done, and combine the two by showing geographic data on a PDA that is not in plan. When the user enters their co-ordinates, the system will draw the horizon, and label all the hills. The user will have an easy interface so that they can scroll through the horizon. They will also be able to get other information, for example their current height, or the height of a particular mountain they can see. There will be a supporting PC application which will allow the user to choose what data is supplied to the PDA, as well as having extra functionality, for example displaying the horizon for any given point. The user will also be able to define markers, for example their route's start point or the place they intend to have lunch, which will feature in the horizon on the PDA whether or not they can actually see them. <heading>Progress to Date</heading>This is a report of my progress, 6 months after writing the preliminary report. <heading>Analysis and Design</heading>The set of requirements have changed significantly since the preliminary report as the focus has moved from a fully-featured PDA application with a small supporting PC application to two well-featured applications - one for PC and one for the PDA. Some restraints have been added after making a prototype, which highlighted unforeseen problems. An example is the new requirement that height data featuring on the horizon has to be at least 1.5 km from the observer. This is because it was only when the prototype had been made that I realised that close data is too sparse relative to distant data to be meaningful. The current set of requirements is as follows: <list><heading>For the PC Application:</heading>For the user to be able to select the area of the country in which they are going to walk, either from raster Ordinance Survey maps, or from graphical height maps.To convert the relevant height data into a format easily read by the PDA.To create a data file containing all of the hills that fall within the range specified by the height data above.To allow the user to see the horizon of a point within their walk from this dataTo show the user what areas of the map the horizon representsTo give the user the ability to add 'markers', for example the start and end points of the route. These will be displayed on the PDA whether or not the land upon which they are found is physically visible to the user.</list><list><heading>For the PDA Application:</heading>For the user to be able to enter their current grid-referenceTo tell the user their heightTo draw a horizon:Representing a scrollable 360 degree panoramaContaining only data at least 1.5km from the observerNaming all identifiable hillsBeing able to show how far a hill is away, and its heightFor markers to be labelled, whether or not they are visible, along with how far they are away.For the horizon to be drawn in a reasonable amount of time (i.e. within 20 seconds)For the horizon to be easily navigable, so that the user knows the direction in which the current portion of the scrolling horizon is facing.There shall be a representation of the horizon that fits into one screen-width, which can be used to show where the current window is on the horizon, and allow the user to click to jump to another part of the horizon.There shall be a compass pointing in the direction (relative to the orientation of the PDA) that the horizon is currently looking.To give the user the ability to add markers.</list>The prototype has been invaluable in deciding what is feasible and in creating new ideas, and it has also meant that I was able to start the actual implementation with the designs of the algorithms and data structures fairly fixed. <heading>Development and Implementation</heading>The first stage of the development was to make a prototype in Microsoft Visual Basic. I chose this language as it is very fast to program, and the fact that the efficiency of the prototype wasn't an issue. The prototype is a PC application that allows the user to click on a graphical representation of the height data of the current map, and set an observer to this point. The program will then draw the 360 horizon and label all the hills. <figure/>One of the most important things I decided while making the prototype was the way in which the algorithm would work. The first thing I tried was to use a sector: <figure/>In the diagram above, a sector of angle A is swept around the observer. For every position of the sector, the elevations for every item of height data are looked at and the maximum is taken as the height of the horizon for that sector. Note that angle A is much larger in the diagram than in the program. Angle A is typically about 0.25. This method is quite slow, however, because every time angle A is moved, each height reading in the quadrant needs to be checked to see whether it falls within the sector. A better solution is the following idea: <figure/>The line sweeps around the observer, and at each point the program interpolates along the line at a given interval. This means that it can find the map data item directly for each reading, and then take a maximum at the end. This method is about 20 times faster than the previous method in a 20km square map, so as efficiency is such an issue with a PDA, this was perhaps the most important finding of the prototype. Another very important thing that the prototype made me realise was the significance of close data. <figure/>If the observer is standing on a steep slope, then it is very reasonable for an adjacent height in the map data to be significantly higher than the observer is, given that the adjacent square is actually 50m away on the ground. Suppose, for example, that the shaded square was a lot higher than the observer (marked with a black circle). In this case, the elevation of this reading will probably be the maximum of any line that interpolates through. This will mean that 90 degrees of the horizon (from North-West to North-East) will be all based on one reading. This will give a misleadingly flat line through a quarter of the horizon as so much of what the observer can see is assumed to be the same as one single height reading. There seems to be only two ways of fixing this. That is either to have more data (a reading every 10m for example), or to ignore all the readings within a radius of the observer. If we supplied the PDA with data at 10m intervals (the next scale that DigiMap produces) rather than 50, we will be giving in effect 25 times more data. This is far more than can be expected to be processed in a reasonable time, so is unrealistic. I decided to give the application a radius of 1.5km within which all data is ignored. I chose this figure because a single item of data 1.5km away takes up a modest amount of horizon, and so looks natural. A map can be selected for the prototype graphically using a second program (shown below). The main reason I implemented this was so that I knew how the maps fitted together and understood where a single map was in relation to the country. <picture/>The third program I made used a hill-climbing algorithm to refine the grid-references of the hill summits to the local highpoints. The following capture shows it in operation. For each hill, the first entry in the list is the original set of co-ordinates stored for its summit, and this is refined over each iteration till the final entry for that mountain in the list is the new summit at the local highpoint. <picture/>I then used the experience and knowledge gleamed from the prototype to make an application for the PDA. I am currently at the stage where a horizon is drawn to the PDA, and am finalising the code for the hills to be labelled. <picture/>For a full description of the development and implementation process, please refer to the project log. <heading>Testing, Quality and Correctness Analysis</heading>The main problem I have been having through this project is determining whether a horizon is accurate. It is very difficult to look at a line on a screen and decide whether it looks like a Welsh mountain. For this reason, I installed ArcGIS, which allowed me to drape a raster Ordinance Survey map over a range of height data, and then observe a hill from a particular spot. I have proved the horizon to be accurate in this way by creating two views of Snowdon from Yr Aran. ArcGIS rendered one, and my program the other. In the following image, for example, the top line is the output from the program, and the coloured mountains are the output from ArcGIS. When superimposed, one fits exactly on the other, and this seems to be the case wherever you set the observer, and whichever direction you look. I concluded, therefore, that the horizon algorithms are accurate. <figure/>This term I plan to test the project further by taking it to Snowdonia and testing it in the field. This will be a very good indication of how accurately the horizon resembles what the observer can actually see. I will take photographs to highlight any discrepancies. <heading>Plan for the Remainder of the Project Period</heading><table/><table/>As the Gantt chart above indicates, my plan is to first finish the PDA application. This should be done in about a week, and at this point I will write the PC application and take the PDA application to Snowdonia to test it in the field. The PC application should take between 3 and 4 weeks. Towards the end of the implementation period for the PC application I will demonstrate both applications, then I will perform full testing and add any other features that seem necessary. I will then start work on the final report. <heading>Summary and Critique</heading>The requirements for the project have changed substantially since the preliminary report due to what has been learned from the prototype. For this reason, it is very difficult to compare the Gantt chart in the preliminary report with that of this report and decide whether or not I am on schedule. I believe, however, that I am on schedule as I have completed all the algorithms and the entire system has been designed. The implementation of the PDA application has been far faster than I was expecting because I am so familiar with the workings of the algorithms. I am hoping that the PC application will be just as swift to implement, in which case I will be ahead of schedule. I think if I continue at my current rate, I should finish well in time for the deadlines. The PDA application is running slower than I was expecting, however, but this is due to the speed of the PDA rather than the algorithms. I will make the code as efficient as possible to increase the speed. I have realised that memory space is less of an issue on a PDA than processor speed, as usually only one program is running at once. Therefore it is generally better to perform one calculation and store the result to use again than to repeat a calculation. I have made the program, therefore, calculate the distance from the observer to everywhere on the map before the horizon algorithm runs. This means that these will not need to be recalculated. I am extremely pleased with the accuracy of the horizon, as supported by the tests I made with ArcGIS. 