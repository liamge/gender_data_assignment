<heading>Question 1</heading><heading>Aim</heading>To define a function that takes an integer list as its argument, and returns the number of negative integers in the list. <heading>Code</heading> FORMULA  <heading>Explanation</heading>This solution is split into functions: the main non-recursive function, CountNI, and the tail-recursive helper-function, CountNI2. <table/><table/>If CountNI is called with an empty list as its argument, it returns a 0. For any list other than an empty list, CountNI calls CountNI2 with the num argument initially set to zero. CountNI2 is called initially from CountNI, and then later by itself. It recurses down to the point where its first argument is an empty list, at which point it returns num, the number of negative numbers it found. Until it gets to an empty list, it adds one to num if the head of the list is negative and then recurses with the tail of the list and the value of num. With any finite list, the function will terminate after a finite space of time, as with each recurse the list gets one item shorter, and it terminates when the list is empty. <heading>Test</heading> FORMULA  <heading>Conclusions</heading>This solution appears to work in both extreme and usual conditions. As it is tail recursive and so only runs a function once for each item in the list, its scope for improvement in terms of efficiency is very limited. <heading>Question 2</heading><heading>Aim</heading>To define a function that takes two lists as its arguments and returns a list containing all the items that are common to both lists. <heading>Code</heading> FORMULA  <heading>Explanation</heading>This solution is split into three functions: the main non-recursive function, CommonElement, and the tail-recursive helper-functions, CommonElement2 and IsInList. <table/><table/><table/>IsInList takes a list and a polymorphic variable, compares the variable to the head of the list, and if different recurses down with the tail of the list. At the point in which the variable is matched to the head of the list, the value of true is returned and the function terminates. If the list becomes empty without matching at all, a value of false is returned. The function will always terminate after a finite amount of time if the list is finite, as the list becomes an item smaller each iteration, and the worst-case scenario is that it terminates when it's empty. As it only looks at each item in the list once, and stops when the item has been found, it is running at optimal efficiency. CommonElement is the main function; it's the one that'll be called by a user. It simply takes the two lists to be compared as its arguments, returns an empty list if either of them are empty, or calls CommonElement2 with the two lists and the empty list if not. CommonElement2 is a tail-recursive function that takes the two lists to be compared, L1 and L2, and NewList, an accumulative list of the results. What the function basically does is to see whether each of the items in L1 is in L2, and those that are are added to NewList. L1 gets an item smaller with each recursion, and the function terminates when it is empty. Therefore with a finite list as L1, the function will always terminate after a finite length of time. The List L2 remains constant. For want of a better method, I've had to make two very similar patterns. One for the first iteration of the function, when NewList is empty, and one for all of the other iterations. Without the default wildcard pattern at the end, the matching would not be exhaustive, as there has to be something L2. The situation of there not being anything in L2 should never occur, as only non-empty L1 and L2 arguments are passed to the function by CommonElement. In case an error does occur though, I've used a failure as the default pattern. <heading>Testing</heading> FORMULA  <heading>Conclusions</heading>This solution appears to work in both extreme and usual conditions, with different data types. As both of the recursive functions are tail recursive, and both terminate as soon as they can, they can be said to be efficient. Working together, these functions only compare each item in the first list with every item in the second list until a comparison is successful or the end of the second list is reached, when it goes to the next value in the first list. This is the most efficient method for implementing this solution that I can see. <heading>Question 3</heading><heading>Aim</heading>To define a function that takes a list and an element as its arguments and returns a list identical to the given list, but with each occurrence of the element removed. <heading>Code</heading> FORMULA  <heading>Explanation</heading>The solution is composed of a main function that will be called by the user, DelElement, and a tail recursive helper function, DelElement2. <table/><table/>DelElement takes a polymorphic list, L1, and a polymorphic variable, LookingFor. If L1 is empty, it returns an empty list, otherwise it calls DelElement2. DelElement2 takes a polymorphic list, L1, a polymorphic variable, LookingFor, and a second polymorphic list, NewList. L1 gets smaller as the function recurses. When DelElement2 is run with a finite list L1, it will always complete in a finite space of time as L1 gets an item shorter each iteration and when it is empty the function terminates. There are two different cases where DelElement can terminate. One is when L1 is empty. This is the usual case, as it means that there are still some items in the list after the specified elements are removed. The other case, of course, is when there are no items left in the list, i.e. if every item in the list matched LookingFor. The function builds up the accumulative NewList in reverse, as it is much more efficient to add an item to the head of a list than to concatenate it. As DelElement2 passes out NewList, it reverses it using the rev function. <heading>Testing</heading> FORMULA  <heading>Conclusion</heading>The solution seems to work with both typical and extreme data, whether or not the element to be deleted occurs at the beginning or the end of the list. It is truly polymorphic and so works with different data types as shown. As the algorithm is tail recursive, and looks at each element of the list once only, it can be said to be efficient. <heading>Question 4</heading><heading>Aim</heading>To define a function that takes two lists as its arguments and returns a list containing the elements of the first list that aren't in the second. <heading>Code</heading> FORMULA  <heading>Explanation</heading>The solution is split into three functions: the main non-recursive function, ListDifference, and the tail-recursive helper-functions, ListDifference2 and IsInList. IsInList is as in question 2. <table/><table/><table/>IsInList takes a list and a polymorphic variable, compares the variable to the head of the list, and if different recurses down with the tail of the list. At the point in which the variable is matched to the head of the list, the value of true is returned and the function terminates. If the list becomes empty without matching at all, a value of false is returned. The function will always terminate after a finite amount of time if the list is finite, as the list becomes an item smaller each iteration, and the worst-case scenario is that it terminates when it's empty. As it only looks at each item in the list once, and stops when the item has been found, it is running at optimal efficiency. ListDifference is the main function; it's the one that'll be called by a user. It simply takes the two lists to be compared as its arguments, returns an empty list if either of them are empty, or calls ListDifference2 with the two lists and the empty list if not. ListDifference2 is a tail-recursive function that takes the two lists to be compared, L1 and L2, and NewList, an accumulative list of the results. What the function basically does is to see whether each of the items in L1 is in L2, and those that are not are added to NewList. L1 gets an item smaller with each recursion, and the function terminates when it is empty. Therefore with a finite list as L1, the function will always terminate after a finite length of time. The List L2 remains constant. For want of a better method, I've had to make two very similar patterns. One for the first iteration of the function, when NewList is empty, and one for all of the other iterations. Without the default wildcard pattern at the end, the matching would not be exhaustive, as there has to be something L2. The situation of there not being anything in L2 should never occur, as only non-empty L1 and L2 arguments are passed to the function by ListDifference. In case an error does occur though, I've used a failure as the default pattern. <heading>Testing</heading> FORMULA  <heading>Conclusions</heading>This solution appears to work in both extreme and usual conditions, with different data types. As both of the recursive functions are tail recursive, and both terminate as soon as they can, they can be said to be efficient. Working together, these functions only compare each item in the first list with every item in the second list until a comparison is successful or the end of the second list is reached, when it goes to the next value in the first list. This is the most efficient method for implementing this solution that I can see. <heading>Question 5, Version 1</heading><heading>Aim</heading>To create a function that takes two lists and returns a single list containing all of the items in each list, without repetition. <heading>Code</heading> FORMULA  <heading>Explanation</heading>The solution is split into three functions: the main non-recursive function, ListUnion, and the tail-recursive helper-functions, ListUnion2 and IsInList. IsInList is as in question 2. <table/><table/><table/>IsInList takes a list and a polymorphic variable, compares the variable to the head of the list, and if different recurses down with the tail of the list. At the point in which the variable is matched to the head of the list, the value of true is returned and the function terminates. If the list becomes empty without matching at all, a value of false is returned. The function will always terminate after a finite amount of time if the list is finite, as the list becomes an item smaller each iteration, and the worst-case scenario is that it terminates when it's empty. As it only looks at each item in the list once, and stops when the item has been found, it is running at optimal efficiency. ListUnion is the main function; it's the one that'll be called by a user. It simply takes the two lists to be compared as its arguments, returns an empty list if either of them are empty, or calls CommonElement2 with the two lists if not. ListUnion2 is a tail-recursive function that takes the two lists to be compared, L1 and L2 as its arguments. L1 reduces in size by an item each iteration, while L2 accumulates as each new item from L1 is added. What the function basically does is to see whether each of the items in L1 is in L2, and those that are not are added to the beginning of L2. L1 gets an item smaller with each recursion, and the function terminates when it is empty. Therefore with a finite list as L1, the function will always terminate after a finite length of time. At this termination, L2 is returned. Without the default wildcard pattern at the end, the matching would not be exhaustive, as there has to be something L2. The situation of there not being anything in L2 should never occur, as only non-empty L1 and L2 arguments are passed to the function by ListUnion. In case an error does occur though, I've used a failure as the default pattern. <heading>Testing</heading> FORMULA  <heading>Conclusions</heading>This solution appears to work in both extreme and usual conditions, with different data types. As both of the recursive functions are tail recursive, and both terminate as soon as they can, they can be said to be efficient. Working together, these functions only compare each item in the first list with every item in the second list until a comparison is successful or the end of the second list is reached, when it goes to the next value in the first list. This is the most efficient method for implementing this solution that I can see. The two problems with this solution are that the return list is given out of order (it's the different elements in L1 reversed then L2), and if an item is in L2 twice it is in the resulting list twice. If an item is in L1 twice, however, it is only in the resulting list once. A better method, perhaps, would be to concatenate the two lists and then remove the duplicates. I've implemented this in the new improved Question 5, Version 2. <heading>Question 5, Version 2</heading><heading>Code</heading> FORMULA  <heading>Explanation</heading>The solution is split into four functions: the main non-recursive function, ListUnion, which calls the non-recursive function CheckDuplicates, which uses the tail-recursive functions CheckDuplicates2 and IsInList. IsInList is as in question 2. <table/><table/><table/>IsInList takes a list and a polymorphic variable, compares the variable to the head of the list, and if different recurses down with the tail of the list. At the point in which the variable is matched to the head of the list, the value of true is returned and the function terminates. If the list becomes empty without matching at all, a value of false is returned. The function will always terminate after a finite amount of time if the list is finite, as the list becomes an item smaller each iteration, and the worst-case scenario is that it terminates when it's empty. As it only looks at each item in the list once, and stops when the item has been found, it is running at optimal efficiency. CheckDuplicates2, CheckDuplicates and IsInList together takes a polymorphic list and returns a list identical to the inputted list, but with no duplicates. The order of the list is maintained as the functions in effect delete the 2 nd, 3 rd, 4 th etc occurrence of each element, but leaves the first occurrence intact. To do this, it in effect starts from the right hand end of the list, and only adds the item as the head of L2 if the item is not repeated throughout the rest of the list. In this way, L2 ends up being a list of all the left-most occurrences of each item. As it is difficult to work with a list from right to left, CheckDuplicates2 is passed the reverse of the list by CheckDuplicates, so that it can operate from left to right but have the effect of operating from right to left. CheckDuplicates2 has two arguments. The first is the List that it has been passed to be checked. This is reduced by an element with every iteration until it gets to the empty list, where the function terminates. The function will always terminate after a finite space of time if this list is finite because of this fact. The second is an accumulative list that will ultimately be passed out as the result of the function. It is ListUnion that is called by the user. ListUnion concatenates the two polymorphic lists it has as arguments and passes the result to CheckDuplicates to remove the duplications. <heading>Testing</heading> FORMULA  <heading>Conclusions</heading>This solution appears to work in both extreme and usual conditions, with different data types. As both of the recursive functions are tail recursive, and both terminate as soon as they can, they can be said to be efficient. The concatenate function is not very efficient, but as it is used only once in a non-recursive function, this fact is not very relevant to the overall efficiency. <heading>Question 6</heading><heading>Aim</heading>To define a function that takes two lists and returns a Boolean value to say whether all of the elements of the first list are in the second. <heading>Code</heading> FORMULA  <heading>Explanation</heading>The solution is split into three functions: the main non-recursive function, SubList, and the tail-recursive helper-functions, SubList2 and IsInList. IsInList is as in question 2. <table/><table/><table/>IsInList takes a list and a polymorphic variable, compares the variable to the head of the list, and if different recurses down with the tail of the list. At the point in which the variable is matched to the head of the list, the value of true is returned and the function terminates. If the list becomes empty without matching at all, a value of false is returned. The function will always terminate after a finite amount of time if the list is finite, as the list becomes an item smaller each iteration, and the worst-case scenario is that it terminates when it's empty. As it only looks at each item in the list once, and stops when the item has been found, it is running at optimal efficiency. SubList is the main function; it's the one that'll be called by a user. It simply takes the two lists to be compared as its arguments, returns true if both lists or just the first list is empty, false if just the second list is empty, and calls SubList2 with both lists if neither are. SubList2 is a tail-recursive function that takes the two lists to be compared, L1 and L2. What the function basically does is to see whether each of the items in L1 is in L2. As soon as it finds one that is not in L2, it returns false and terminates. If it gets to the end of the list without finding one that's not in L2, it returns true and terminates. L1 gets an item smaller with each recursion, and the function terminates when it is empty. Therefore with a finite list as L1, the function will always terminate after a finite length of time. The List L2 remains constant. Without the default wildcard pattern at the end, the matching would not be exhaustive, as there has to be something L2. The situation of there not being anything in L2 should never occur, as only non-empty L1 and L2 arguments are passed to the function by SubList. In case an error does occur though, I've used a failure as the default pattern. <heading>Testing</heading> FORMULA  <heading>Conclusions</heading>This solution appears to work in both extreme and usual conditions, with different data types. As both of the recursive functions are tail recursive, and both terminate as soon as they can, they can be said to be efficient. <heading>Question 7</heading><heading>Aim</heading>To create a function to take two lists and return a Boolean value representing whether the two lists are the same apart from their order. <heading>Code</heading> FORMULA  <heading>Explanation</heading>The solution is split into two function groups, in effect. The non-recursive DelElement and its tail-recursive helper-function DelElement2 take a polymorphic list and a polymorphic variable and return the list with the first instance of the variable removed. The second group is the non-recursive IdenticalList and its tail-recursive helper-function IdenticalList2. It is IdenticalList that is called by the user. <table/><table/><table/><table/>DelElement and DelElement2 together take a list and a variable and remove the first instance of the contents of the variable in the list. DelElement2 keeps iterating with L1 getting an item smaller each time until L1's head matches LookingFor. At that point it returns the list with L1's head removed. To do this, it stores the items in the list that it has already checked in L2, and concatenates the two lists as it terminates. The function will always terminate after a finite amount of time if L1 is finite, as L1 becomes an item smaller each iteration, and the worst-case scenario is that it terminates when it's empty. As it only looks at each item in the list once, and stops when the item has been found, it is running at optimal efficiency. The relatively inefficient concatenate operation is only ever run once. The grand idea of IdenticalList is this: if L1's head gets removed from both lists with each iteration, then if the lists are identical apart from their order, then both should become an empty list at the same iteration. Therefore, if one gets to an empty list before the other, then they are not the same, and a value of false can be returned. If they both get to an empty list at the same time, a value of true can be returned. This function will always terminate if L1 is finite, as it is getting smaller with each iteration until it terminates at an empty list. It may terminate before this point, however, if L2 is smaller than L1. <heading>Testing</heading> FORMULA  <heading>Conclusions</heading>This solution appears to work in both extreme and usual conditions, with different data types. As both of the recursive functions are tail recursive, and both terminate as soon as they can, they can be said to be efficient. There are no efficiency-costing concatenate functions in the recursive bits of the functions, just once as a value is passed out. <heading>Self-Reflection Task</heading>As I got into this piece of work, I enjoyed doing it more than I expected. There's a great moment on each question where you press enter after putting in a lot of code or chasing a bug and it all just works. I have learnt a lot about using lists in Caml, as I hadn't that much experience with them before. I have previously written two or three functions that act on or use lists, but I've never written a function with two lists as its arguments before. I think the thing I found most difficult was remembering to use the right brackets all the time in the functions, and remembering which variables contained lists, and which contained single variables. I often got type synthesis errors when it tried to match int list list list with int list list, when everything should really just be int list. Once I gained experience of identifying where the mistakes were, I was able to program the functions in the latter questions with very few errors and bugs. I think that after doing this coursework, I have a much more mature and experienced view of programming in Caml, and find it easier to see how problems can be tackled in a functional way. 