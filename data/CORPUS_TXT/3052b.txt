<heading>Brief presentation of the DirSync program:</heading><heading>Role of this program:</heading>The DirSnc program is used in order to synchronize two directories. The command line used to launch this program follows,  FORMULA  where source is the name of the source directory and dest, is the destination directory. dest will contain exactly the same files than source. We can add some options to this command line. This options can be useful when we want exclude some directories from the scanning or determine the file removing condition (for example, if dest contains a file wich is also contained in source, what is the condition for replace it or not? Option - m can determine it. The file will be replace if it has a different size or date (default option) or will be replace if the destination is oldest than the source file). During the synchronisation, if a file exists in the dest directory and not in the source directory, it will be deleted. However, we can add an option (-r) in order to keep missed files in the dest directory. <heading>Code source files contained in this program:</heading>Of course, several sources files are requisite. However, one main file which is called dirsync.c exists. The others files are used to execute some functions which have already been written in another project. For example, the file dirent.h and dirent.c which are used in order to read the content of a directory have been written by another programmer. So dirsync uses these open source file. This is the power of an open source function, we can use it without ask the agreement to the owner. This is also the case for the getopt.c and getop.h files which are used to read and analyse every arguments/options enter in the command line. The main function is contained in the dirsync.c file. This file contains every function concerning files manipulations (delete, copy, etc...) (More details about this function follows in an other paragraph). <heading>Brief description of the modification:</heading>This coursework (including coursework 4) will produce a modification to this program. Actually dirsyn doesn't allow the synchronisation of two directories which are not in the same machine. So, this modification will allow that dirsync will be able to synchronise two directories on two different machines. We have to be careful about this point, there are several case: When the source is on the local machine (which executes dirsync) and the destination is on another machine than the local machine. When the source is on another machine and the destination is also in another machine. When the source is on another machine and the destination is on the local machine. When the both are in the local machine (currently dirsync manage it but after the modification, dirsync has to manage it again, so we have to think about that !) <heading>Dirsync and modifications in details:</heading>In this part, we will explain how dirsync is working, adding some part of source code, then we will see how and where the modification will be inserted. <heading>Dirsync without modifications:</heading>First of all, it's important to say that if we want to compile dirsync, we have to declare a global constant (in the dirsync.c file) which is called __LINUX__. This constant makes the current OS type clear. It's important because some pre-compilation instructions need to know this constant in order to include (or not) some system file in the program for the compilation. <heading>Data structures:</heading>Here is explained some data structure which is very important in the program. It is important to understand this structure because these will be useful for the modification: This type is useful in order to make list structure (link queue) (which is useful for the list of the file in a directory for example):  FORMULA  The simple schema below illustrate this structure, <figure/>Where A and B are two Link_T. Directory_S represents the content of a directory. Actually "files" represents a list of the files contained in the directory and "dirs" a list of the files contained in the same directory. "files" and "dirs" are both FileArray_T which is explain in the next step,  FORMULA  FileArray_S is a type which represents a list (queue) of files or directories. It contains 3 attributes: head which is the first element in the queue, count which is the number of element in the queue and entry which is an array containing the entry (the files or directories).  FORMULA  Entry_S is a type which represents an entity in the queue. An entity has a name and a link which point on the next entity of the list (queue). Statb is useful to store the different properties of the file or directory (date of last modification, ...). Statb is useful when we want to kow if a file has to be copied or not during the synchronisation.  FORMULA  Of course, there is some others data structures but we define here only the most important for the futures modifications. We can simplify these structure by the below schema. The content of a directory is represented like that, <figure/><heading>Functions:</heading>This program contains a main() function which will analyse the command line. Then, the synchronisation is executed by a function called dirSync. This function will analyse the contents of the directories (source and dest), then process to the synchronisation. In this part, we will explain how the synchronisation is done. <heading>The main() function:</heading>First of all, this function initialize some queue: excludedDirs, excludedFiles and excludedRegex calling the function QueueInit(). These queues are used to store the excluded Dirs, Files and Regular Expression which are specified in the command line. Then, a loop is used in order to analyse the command line and read the options and argument (calling the function getopt()). This part will be useful when we will modify the program. The buffer initialisation is then done (we can define the buffer size in the command line). The buffer is the size used to copy the file (this mechanism is explained below). Finally, main() calls the dirsync() function which will synchronize the two directories. <heading>The dirSync() function:</heading>This function is very important. We have to understand how it works in order to process to the modification. This function receives two arguments (two char*): source and destination which are the source directory and the destination directory. First of all, dirSync() calls ScanDir() twice (once for source, once for destination) in order to build and fill the structure which will contain every files and directories contained in each directories. In order to fill it, the method "insert in head of queue" is used. These structures are Directory_T type. Some basics functions are written to access, write, read etc...elements in this structure (for example ArraySearch(),EntryAdd(),... ). Once these structures filled, the synchronisation contains 4 steps. In the next part, we will explain these steps and some functions calls. Step 1: Delete all files not present in the source: This step is done iteratively by reading every file name contain the queue filled before. Of course, the file if deleted if and only if the option '-r' didn't specify in the command line (this option does not allow the elimination of the missed file. This function calls some simple others functions contained in the same file (dirSync.c). <list><heading>The system calls used here are:</heading>chmod(): this function change the mod of a file (like chmod command in a Shell)unlink(): this function delete the name of a file (and free the drive space)</list>Step 2: Delete all directories not present in the source: This step is similar than the previous step. However this step read every directory name contained in the source directory. <list><heading>System calls in this step are:</heading> - rmdir(): which will delete a directory</list>Step 3: Copy all files changed from the source directory to the destination directory: This step will copy the files from source to destination when it's necessary. If the file is not in the destination directory, then it will be copied. If the file is already in the destination directory, then this function will analyse the file stat (date of last modification and file size) contained in the source directory and determine if it has to be copied ("yes" if the date is different (default) and if the option " - m 1" is specified, then "yes" if the destination file is oldest than the source file). In order to copy a file (when it's necessary), this function calls FileCopy() which processes to the copy. The copy is not a simple call to a "copy" function but an iterative copy. A loop reads a number of byte in the source file (this number is the buffer size which is determine in the buffer global variable) and write it in the destination file (by checking if the number of read bytes is equal to the number of written bytes). This is done with the system function: open(), read() and write(). Step 4: Call dirSync in each sub directories: Of course, the source directory can contain others sub directories which can contain others files and sub directories etc... So, we have to call dirSync for each sub directory with a recursive call. So, in this step, a loop read every directory name contained in the source directory, create a similar directory name in the destination directory (if this doesn't exist) and finally call dirSync() function for this sub directory which will apply this 4 step for this directory. <list><heading>System calls in this step are:</heading> - mkdir(): which will create a directory</list>The synchronisation is simplifies in the schema below, <figure/><heading>Conceivable modification:</heading>We have to find a solution which will allow that the synchronisation between two directories which are located in two different machines. We will explain in this part the conceivable solution and explain where we can modify the code source. <heading>Details on futures modifications:</heading>Each case have to be treated: source is local and destination is distant, ... First of all, an option (in the command line) will be added. This option is "w" which means "where". Four different values can be used: "-w l", "-w s", "-w d", "-w sd".  FORMULA  So, if this option is specified, then the program will know which directory has to be treated like an distant directory. The directory name in the command line has to be indicated like this:  FORMULA  For example, these command lines will be correct:  FORMULA  <figure/>In order to add the "-w" option possibility, we have to modify this part of code (in the main() function):  FORMULA  Double colon is add after w to precise this option wait for argument (which can be's', 'd', 'sd'). Of course, two or three processes of dirSync have to work: one on the local machine (which will manage the synchronisation and "speak" with the user) and another (or two others) on the distant machine(s) (two if ' - w sd' is specify). This will be done by the creation of a dirSync daemon. Effectively, there will be one client and one (or two) server(s). The daemon (the server) has to be launched in the distant machine. When we will start the daemon on the distant machine, we have to add the option '-d' which means 'daemon'. So a daemon will has to started with this command line:  FORMULA  where 1985 is the port number which will be used for the communication with the client. The daemon will be an indefinite loop which will give to the client some information. The client is dirSync on the local machine which manages the synchronisation. When the client need an information which is on the distant machine (for example the name of a file), it will be able to send a request to the daemon (server). The schema below explain this process, <figure/>When the option '-d' is detected, that means it's a dirSync daemon, so a function (which contains the indefinite loop) is called. The dirSync and dirSync daemon will be defined in the same code source file. This code source will contain 2 parts: one for the daemon and one other for the dirSync 'classic'. In the actual version of dirSync, the source (or destination) is defined with a simple name store in a char* variable (the directory name). However, for the modification, we need to know if the source (or destination) is distant or not. So a type structure has to be defined. This structure will define a source/destination,  FORMULA  So, the source and the destination will be defined by this type (if Distant=0 then only DirectoryName will be used). This type will be defined like a global type. This architecture involves the creation of a function which will manage the daemon and the modification of the others functions which manages the synchronisation (these functions are explained above). In order to illustrate how will be the modification, here is an example. This part of code is in the dirSync function. I will explain below this part of code, which part has to be modify and how we can manage it,  FORMULA  In this part of code, we can see the call ScanDir(source,&dirSource,&statSource). This has to be modified because source may be distant. So we have to add a condition instruction in order to test if the source is distant (with the distant attribute of the sourceDestType structure) and if that is the case we have to send a request to the distant daemon (where the source directory is) and this daemon will be able to send us the result of ScanDir because it will execute it on the distant machine. The result is the structure dirSource. It is the same thing with ScanDir(source,&dirDest,&statSource). Once Scandir called, the array dirDest and dirSource are filled. So we can use it (access) without send a request to the daemon. However, if a file has to be deleted (in the destination directory) and if the destination is on a distant machine, we have to send a request to the distant daemon which asks to him "delete this file". So the daemon has to treat this request. The chmod(dest,0777); instruction has to be treat on the distant machine if the destination directory is distant. That is the same mechanism; we send a request to the distant machine which asks to him "change the directory mod". Above is only the first step of the synchronisation. However, this mechanism has to be used for the rest of the synchronisation. So, the daemon has to treat every case. The daemon receives a request, analyse the type of this request and treat it. Sometimes it will be necessary to send information back to the client (for example to obtain the list of files contains in a directory) and sometimes it won't be necessary to send information back (for example to change the mod of a directory). This mechanism has to be used for every call in the synchronisation. <heading>Conclusion on the problem:</heading>Analyse and understand an existing code is very interested because we can see how other programmer find solution for a problem, and it's often improving. We have to understand very well how the program works before to modify it. Before to start the modification, we have to think about the new structure, new program architecture etc... and when everything is clear, we can begin to modify the program. 