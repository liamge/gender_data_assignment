<heading>Introduction</heading>Blocks-World Management that is playing a far vital role in the development of Artificial Intelligence (AI) is expected to be constructed in this project. The management should be an interface between user and blocks-world so that all the commands from user can cause the specified actions among the elements of blocks-world. Some AI concept should be involved into the operation of making structure and search method. In this report two methods are implemented in C++ to establish blocks-world management, one is trying to build a dynamic blocks world and operate objects in it and the other focuses on the search method for some specified blocks world. Unfortunately, so far, this search method can not be successfully combined into the blocks world management programming, but the research work associated with the effort on them are illustrated in this report <heading>Method and Implement</heading><heading>Approach 1</heading>In the Blocks World management, the user is allowed to dynamically add objects to the blocks world. The Matrix which is of type block is made to store and display the blocks. The line stands for the each stack and the row stands for the height of each stack. Each block in the matrix has ID number, color and shape. When a new block is added in, it will be given an ID number with its specified shape and color then put into the matrix associated with the "on(A,B)" and "ontable" function to build blocks world. When user input the command to operate the objects in blocks world, the position of blocks which are engaged in "void blockstack(int A, int B)" and "void blockunstack(int A, int B)" function can be found by "searchxy" function, which using depth-first-search method.  FORMULA  As a result, in the function of blockstack(A,B) and blockunstack(A,B) the aimed object can be put into the ideal position through "tablestate->statematrix[Bx][By+1] = tablestate->statematrix[Ax][Ay];" and a searched space found by the following method:  FORMULA  Based on the roughly mentioned basic function above and some other in the programming, basic dialogue between user and blocks world is constructed. More details about the programming can be checked in the code list. The state machine is set to allow user to choose two communication modes, one is building blocks world and the other is moving objects in the blocks world depending on the user's command. When the input command can not be implemented via one step, which means "stack" and "unstuck" can not be operated directly, the search method should be called to figure out a "path" to access the target. In the approach 2, a novel search method is discussed. <heading>Approach 2</heading>This search method only concentrates on how to figure out the optimized path from one state to another state. Probably, it can not entirely follow Blocks World specification, but it can be applied in the search part to figure out the best way to get to the desired the state. Three blocks state is taken as example to demonstrate its idea. Totally, there are 13 states for 3 blocks world, they are list in the figure 1 and one state that all the three objects are laid on the ground that is called state zero. From left top to right bottom, they are named as state one to state twelve. Also, if one state can be transferred from another state via only changing one object, the relationship between these two states is set as 1. The relationship between each state are evaluated by this method, therefore put all these results into a matrix as displayed in the figure 2. The paths between each state are showed in this matrix, so the question is transformed into searching shortest way on the graph. The top left corner of the matrix can be taken as the current state, in the mean time the most bottom right corner is the desired states. <figure/>How to find out the path between these two corners should be considered by the search algorithm. Therefore, breadth first search is engaged into the algorithm. In the searching procedure, all the traveled states are put into a linked queue for back track.  FORMULA  The pointer to the rear is set here, and in "void EnQueue(DLinkQueue &Q,PosType e)" the rear point is connected to the node through  FORMULA  The breadth first search is applied in the loop of "while(!found && !QueueEmpty(Q))" at "bool ShortestPath(int matrix[][], int m, int n, Stack &S)" function. Then the searched shortest path is pushed into a stack. More details about it can be seen in the code list. However, this method can not be embedded into blocks world management algorithm so far, because the approach how to let algorithm dynamically establish the matrix to cope with a variety of blocks states is still being thought about. Moreover, how to make algorithm put selected state and desired state into top left corner and bottom right of the matrix automatically is another important problem. <figure/><heading>Conclusion</heading>In this project, some AI concepts are applied in a practical AI planning topic. Breadth first search method and depth first search method are utilized in this project, though part of them are not very successful so far. 