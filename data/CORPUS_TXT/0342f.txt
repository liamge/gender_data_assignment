<abstract><heading>Summary</heading>The main objective of this report is for me to understand how the two seven segment displays on the M16C microprocessor are driven on a time multiplexed basis, which output pins of the microprocessor are required to activate both the individual segments of the seven segment displays and how to activate a particular display device along with the required voltage levels. As well as this I must understand how manipulate code to rotate one segment of the LED1display clockwise, then displaying all of the segments simultaneously and then displaying only the decimal point. I achieved this by investigating how to use HEX code in a lookup table to display the desired segments at the correct time. I managed to display the output specified in the briefing sheet. </abstract><heading>Introduction</heading>The aim of this laboratory was to write a program for the M16C microcontroller to rotate one segment of the LED1 clockwise then output all of the segments simultaneously then displays only the decimal point and repeats. Code was written using the IAR Embedded Workbench software. A look-up table for the LEDs in terms of bytes was required as well as defining the input/output ports and code to switch the correct LED on. The objective of the report was to enhance knowledge of extended C programming code, specifically in this case the code required to control the M16C microcontroller. <heading>Theory</heading><heading>Time multiplexing</heading>The two LED segment displays are both run from the same eight output pins of the microprocessor. If both LED segments are set to display information from these ports at the same time, they will display the same data. The eight output pins change state at a very fast rate. Alongside these eight pins are two more output pins. These select which LED segment display information. At one moment in time, one LED segment shall be displaying information from the eight output pins; milliseconds after this, the other segment shall display information (which has now changed) from the same pins. To the user this has the effect of both LED segments being controlled separately at the same time from only eight output pins and two LED selector pins. This is due to the fact that the human eye cannot respond to the difference in the displays fast enough. If a slow motion camera was to capture information displayed on the two different segments they would seem to flash on and off one after the other. <heading>Defining the LED look-up table</heading>The seven segment LED display below shows the arrangement of the different segments corresponding to the different output ports shown in the table below. For a segment to be displayed, the corresponding output port must be low. For example, to display zero, ports corresponding to segments A, B, C, D, E and F would all have to be low, whilst G and DP would need to be high (any values referred to as "high" or "1" are above 5V DC, "low" or "0" values are 0V DC). <table/><picture/>Ports P1.0 and P1.1 state which LED display is receiving data and therefore which LED segment is on. A high output from P1.0 causes LED1 to display all P0 bits. A high output from P1.1 causes LED2 to display all P0 bits. If the LED segment was to display 0, in binary the output ports would be displayed as follows: <table/>The look-up table for the program is displayed in HEX. Therefore, the binary numbers equivalent to the desired output display of the LED display must be converted into HEX to be inserted into the lookup table. The table below shows how to convert binary digits into hex. <table/>To display 0 (as shown in binary above), the binary code to control the LED display would have to be split in into 2 HEX digits. The HEX code to display "0" on the LED segment would therefore be C0 (binary code = 11000000). <table/><heading>Method</heading><heading>Defining the lookup table</heading>The desired lookup table has the effect of rotating one segment of the LED1 clockwise, then displaying all of the segments simultaneously and then displaying only the decimal point. From the code provided in appendix C of the briefing sheet (see appendix) for the laboratory we can see the first HEX digits in the lookup table is C0. This causes A to be lit on the seven segment display (binary code 111111110). FD are the next digits given, causing B to be lit on the seven segment display (binary code 11111101). The next HEX digits for the lookup table are not defined in the code given in the briefing sheet. The next HEX digits would need to display the segment equivalent to C, D and  E on the seven segment display. The binary code required to display C, D and E is shown below: <table/>Using the table provided in page 1 of the appendix, it can be shown that the binary number to display C is equivalent to FB, the binary number to display D is equivalent to F7 and the binary number to display C is equivalent to EF. <table/>The code provided in appendix C of the briefing sheet (see appendix) then shows DF, BF, 7F, 00, 00 in the lookup table, these HEX decimals display (in consecutive order) F, G, DP and all segments twice. This has the desired effect of rotating one segment of the LED1 display clockwise, then displaying all of the segments simultaneously and then displaying only the decimal point. It does not however cause the segments to be displayed in the correct order. The lookup table would display one rotating segment, then display the decimal point and then display all segments for twice as long as any other segments are displayed. The required lookup table with the correct segments being displayed in the correct order is displayed below: <table/>This has the desired effect of rotating one segment of the LED1 display clockwise, then displaying all of the segments simultaneously and then displaying only the decimal point. <heading>The code:</heading><quote>#define Chip_3062x // Commands to the pre-processor. #include "stdio.h" // Instructs the pre-processor to incorporate in the #include "iom16c62.h" // program the contents of the stdio and iom16c62. unsigned char dis_code [10] = {0xFE, 0xFD, 0xFB, 0xF7, 0xEF, 0xDF, 0xBF, 0x00, 0x00, 0x7F} // Lookup table set as explained. int count; // Defines the variable "count" as an integer. void wait (unsigned long delay) // Wait function which does not return a value // (without this function the segments would change // so fast that the user would not be able to see them { while (delay !=0) // While the delay is not equal to zero, loop function. delay--; // Decrement delay until equal to zero. } void main(void) { PD0 = 0x0FF; // Sets the direction of all port 0 bits (all bits // controlling LED segments) to output. PD1.0 = 1; // Sets the direction of LED1 to enable to output. PD1.1 = 1; // Sets the direction of LED2 to enable to output. P0 = 0x0FF; P1.0 = 1; P1.1 = 1; // Set port0 bits high, turning all LED segments off on // both LED1 and LED2. count = 0; // Sets count to "0". while (1) // Continues to display the lookup table value // corresponding to count until count reaches 11 // (count%10 = 1). { { P0 = dis_code[count%10]; // Sets P0 bits to output lookup table values // corresponding to count. P1.0 = 1; // Sets P1.0 high, LED1 displays P0 bits (LED1 is // "on"). P1.1 = 0; // Sets P1.1 low, LED2 is "off". wait( 100000 ); // Sets the "delay" in the wait function to 100000. // Wait function recalled. count++; // Count incremented. } } }</quote>Detailed instructions of how to use the IAR embedded workbench program to allow the code to communicate with the M16C microcontroller is provided in the "Procedure" section of the laboratory briefing sheet (see appendix). <heading>Observations & Results</heading>When the program is run, LED1 displays segments A on LED1, but not on LED2. The segment rotates clockwise around the seven segment display. All LED segments are then displayed for twice as long. The decimal point is then lit. Segment A is then lit again and the process repeats. <heading>Conclusion</heading>During this laboratory I have learnt how the two seven segment displays are driven on a time multiplexed basis. I have also learnt which output pins of the microprocessor are required to activate both the individual segments of the seven segment displays and activate the particular display device along with the required voltage levels. I now know how to manipulate the output ports of the M16C microprocessor to display anything I want to on the seven segment LED displays and the theory behind it. 