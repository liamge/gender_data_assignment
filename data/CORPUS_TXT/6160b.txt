<heading>1. Introductionand informal statement of requirements</heading>In the course of playing the video game Ratchet and Clank, the player will encounter various (often useful) objects. Thus, one of the objectives of the game is to collect as many of these objects as possible. For any given objective (or problem) for which there exists a computable solution, there may be one or more possible solutions which will produce the desired result. This coursework aims to develop one such solution- i.e. to attempt to discover the best way to collect as many objects as possible. <heading>Assumptions</heading>For any model, assumptions about the operating environment must be made. I assume the following: In the game, there exist infinite instances of each of the types of objects (e.g. in a crate containing only apples and pears, there are infinite apples and infinite pears). This allows that at least one of each object can be collected. Also, this assumption is made because the exact numbers are unknown. Objects will be encountered randomly- i.e. randomly distributed within the universal set. Finally, it is assumed that as listed on the exercise sheet, there are 11 distinct objects. <heading>Requirements :</heading>The algorithm must produce a set containing a single instance of each object, with no duplicates. When the set contains one of each type of object, the set is complete and the algorithm will terminate. <heading>2. The Algorithm</heading><heading>Initial conditions:</heading>The universal set U contains infinite instances of all the objects. The set C which will hold the collected objects is initially empty. The constant d is defined as the number of distinct elements in set U, i.e. the number of different objects. For this example, d is assumed to be 11. The variable s is defined as the number of elements in C. It is initially equal to zero. <heading>2a. Expressed informally as a sequence of steps</heading> FORMULA  <heading>2b. Expressed as Pseudocode</heading>In this section I make comments in italics. Arrays are defined using the zero-based convention, thus the first element of array U  is U[0]. NULL  will be used to signify an empty element- when an object is picked up, it is no longer a part of the universal set and the position it was in is now empty.  FORMULA  Next I define the subroutine for the PickUp operation, first the object is "picked up" and added to the collection then the cardinality of C is checked (the number of distinct elements). If newly added object already exists then s+1 will be greater than cardinality of C or else if new object is unique, s+1 = |C|:  FORMULA  I define the subroutine for the Drop operation. The element of the array is set to NULL to represent that object being removed from collection. The removed object U[i] is a duplicate instance of an already existing object in the set C. This is verified by finding the set complement between the set X and C. X contains a single element: the single removed object. If the removed object exists in both X and C then the set complement is an empty set :  FORMULA  <heading>3. Algorithm Properties:</heading><list>Input: The Universal set U containing at least one of each type of object, the number of distinct objects (represented by the constant d).Output: The set of collected objects, C. Definiteness: The main function Play uses a while loop to go through the set U and uses the PickUp subroutine to collect objects and Drop to discard duplicates. Finiteness: When s = d, the set C is complete and contains one of each type of object- at this point the program terminates.Effectiveness: Each step of the algorithm is either a comparison or an assignment operation so will take a finite amount of time.Corrrectness: Yes, algorithm results in a set containing all distinct elements. Tested using d=2 with U containing 5 elements.</list><heading>4. Algorithm Efficiency:</heading>The program is controlled by a while loop so the time need to execute the algorithm is ultimately dependent on the nature of the universal set U as this governs the time taken for the while loop (controlling the program) to complete. A greater number of distinct elements in U results in a longer execution time. The actual execution time is affected by the distribution of the elements within U. For example, when attempting to obtain a set containing the elements {3,1, 4, 2}, the algorithm would achieve this faster from a set such as {2,3,4,1,4,3,1,2,1,4} rather than (2,2,2,2,2,2,2,3,1,4}. On the basis of the model used in developing this algorithm, the execution time would vary due across runs due to the random distribution of the elements contained within the set U (see Assumptions). If the number of distinct objects is given by the constant d, the ideal U set would be one where there is no repetition within the first d elements. Whatever comes after is irrelevant. Using the exercise example of d=11, taking into account 11 runs of the While loop, I estimate that at least 78 (11 x 7 steps per completed While + 1 last check of While condition to terminate) steps are required to obtain a set of 11 distinct objects. This assumes that calling a subroutine is only counted once, as a single step, ignoring their internal steps. <heading>5. Application of Sets:</heading>A common application of sets could be in programs that generate random sets of numbers for lottery tickets, bingo, etc. So for example, with the National Lottery, there may be set U = {1,2,3,4... 48,49}. The program must then generate subsets which contain 6 elements with no repetitions within the sets. 