<abstract><heading>SUMMARY</heading>The paper covers the design, implementation and testing of a reaction game involving two keypads, an LCD screen, SWET box and computer terminal. The team's decision about how to create a reaction game from the equipment, and the reasons behind this are also discussed. Previous knowledge of the team is outlined to put the accomplishments, targets and solutions to problems into a better perspective. The paper covers issues relating to problems that were encountered and action taken towards their solution. Pen ultimately, a discussion on the performance of the system is outlined before the conclusions of the project </abstract><heading>INTRODUCTION</heading>The chosen project was the Reaction Game. It involved using two keypads, and LCD screen and a SWET box to create a game whereby the reactions of two players were pitted against one another. The basic idea of the game was to display something on the LCD screen. The speed at which a correct key was pressed determined who won. From this starting point a more detailed specification was developed (see Analysis of System Specification, Design Details). It was decided that rather than split up responsibilities to each team member it would be more time efficient to work on a single problem collectively. Approximately half way through each of the three lab sessions the role of programmer would switch so as to distribute the work load fairly. Previous experience of using the SWET box was limited to a total of three, three hour lab sessions within the course. LCD screens and the Keypads had never been encountered prior to the project. <heading>ANALYSIS OF SYSTEM SPECIFICATION, DESIGN DETAILS</heading>The project outline given to the team was: <quote>"The object of this project is to implement a game that will test the reaction of two players. Available for this are two keypads, one for each player, each containing 16 switches. A pixel addressable LCD display is also available which can be used to display objects / shapes in various positions to provoke a particular key to be pressed on the keypad."</quote>To fulfil this we first decided on how communicating the required response from the user was to be achieved, it was decided that the goal was to display a random number of lines on the LCD screen as this was an easily understandable task for the user. The second consideration was to then how to check which player pressed the corresponding number on the keypad. E.g. if 7 lines were displayed on the LCD screen a player would have to press "7" on their respective keypad and the system would have to differentiate this from an undesired response. The first player to press the correct key then would win the round. The final consideration was to have some sort of scoring system to add a competitive element to the game, as such it was decided that the game would include 10 rounds which constituted one match. <heading>SYSTEM IMPLEMENTATION AND TESTING</heading>The system was developed using a modular approach. Three phases... <list>Write to screen Read inputs Calculate winner.</list>These three phases were broken down into a number of separate methods detailed below <heading>INITIALISING/ CLEARING SCREEN</heading>Given the project sheet it was decided the first sensible step to take was to familiarise ourselves with the registers and ports to be used. The first step was to initialise the LCD screen to an appropriate default using the given Instruction Codes and values. The default state of the LCD screen was whatever had been on the screen last time the system was active. This necessitated the design of a clearScreen () procedure. This was achieved by iterating through each byte of the display and writing 0x00 (the equivalent of a blank) to the set of pixels. The first few implementations of this code did not work quite as expected but through debugging it was found to be due to the cursor remaining in place when the system was deactivated. This was easily remedied by initialing the cursor to the top left location of the screen when the procedure was called. <heading>DRAWING LINES TO LCD</heading>Now that the screen could be initialised it was decided to implement a method which would write a single line in an arbitrary location on the LCD screen. The project sheet gave the location of the first addressable segment of the LCD screen. The process of writing to the LCD screen involved writing to the data register sequentially. Initially, the CURSOR instruction was written with a value of the first addressable location. This was followed by a WRITE instruction which wrote a byte to the current cursor position. Once this was completed we tested the system by trying to write a number of lines to the screen at defined locations. We found that despite moving the cursor existing lines were not removed, this was a variation of the problems experienced earlier with lines remaining after system shutdown. The problem was solved by calling the clearScreen() method immediately before writing to the LCD screen at different locations. To allow drawLines() method to be called in the future it was extended with the addition of parameters. By passing in two parameters p and q which represented the cursor's CURSOR_L and Cursor_H bytes the method would write to a given location on the LCD screen. To test the method we passed it a number of parameters from the main method. The fact that all lines were written to the correct location sufficiently proved the method was working. <heading>READ INPUT</heading>A key part to the system was being able to read inputs from the keypads. To avoid possible confusion and to provide a base from which to build on we decided to use only one keypad. We would develop the methods to read from one keypad, translate its input and output this number on the monitor. These methods would then be transferable to the second keypad in the final phase of development. The first solution which was implemented was to enter a busy waiting loop whereby values would stream into the system from the input keypad until a value other than the default was detected. In theory the method would work but when put into practice the values were read in at such a rate it was difficult to differentiate between the values Additionally, the values received were incomprehensible to us. Initially we misinterpreted the project sheet and considered the inputs from keypad as one byte outputting a binary value, however on rereading the sheet we found the row and column values as being nibbles in one byte. We worked around this by masking off the first four bits to read the column value, then masking the second four bits and reading in the row value. To combat the excess speed issues we implemented a delay looping procedure delay (loops) which would monopolise processor time for a given time period. The time period was in approximately milliseconds i.e. 5000 results in a 0.5 second delay. This was useful in debugging as it allowed us to document the hard coded values that a keypad press gave these are illustrated below: When reading from keypad A and B we had problems with dropping out of loops. Initially it would wait until A was correct before it checked B; this meant there was no way B could win. The solution to this was to have a found flag with the loop that checked if Keypad A was correct. If not it would drop out of Keypad A loop and read Keypad B. If both were incorrect i.e. found flag = false then the loop would restart reading in keypad A again. <heading>TRANSLATE</heading>Our testing provided us with a set of row and column values for each key pressed on the keypad however in cognitive terms this was hard to understand. We decided that a method which read in these two values and translated them to denary was necessary. The translate (col, row) method post condition was to output a denary value of the inputs. There were two options available. The first option was to develop a loop and a 2D array of the codes associated with each key. The inputted values would determine the location in the 2D array of the denary value. The second option was to simply have 16 if statements which would compare the parameters with each statement until a match was found. We decided that the time needed to implement a 2D array was too much, any slight gain in performance would barely have been noticeable. We decided to keep the system simple and therefore use 16 IF statements, the equivalent of a switch statement in java. A useful feature of this translate feature that we were unaware of at the time of coding is that if the user presses more than one keys simultaneously, thereby 'cheating', then it outputs the default value and behaves if no key is pressed. The testing for translate consisted of a single print statement which would output the translated value of the keypad. We coupled this with our reading loop passing the values to translate() and so streamed output to the terminal window.  FORMULA  However, we never achieved the correct output. Instead of outputting the true value a value of % was output. To solve this two temporary flags were used; if a pre determined key was pushed the flags would be set to 1. A single print statement would output whether the key was pressed. By doing this we could find if the correct value was selected or whether it was our print statement. Our program passed this test and otherwise worked. After seeking assistance we were advised on how to output a denary value of a variable, unlike java c requires you to specify the data type of the output. This immediately solved the problem:  FORMULA  The translate() function was now fully operational. <heading>RANDOM GENERATOR</heading>To have a random sequence of numbers was crucial to ensure longevity of the game. An option was to store a large array of values which we "hard coded" and access them sequentially. A better option was to import the random library into the code. After numerous attempts at importing the library it became evident it was not possible, this was later explained to be due to an incompatibility with the SWET boards hardware. To overcome this setback we decided to utilize user input; users would input a sequence of ten numbers that would be run through an algorithm to give some pseudo random numbers. The algorithm decided upon was our own simple implementation of a prime number driven, modulus based calculation:  FORMULA  To test this equation we passed each possible value that could be inputted via the keypad. The results proved that there was an even spread of numbers. These numbers could be passed into an array which would then be accessed sequentially based on the round of the game. To get these values a simple method called readStart() was created. It read from Keypad A continuously until ten numbers were input. To store the values in an array the translate() method was called. To test the inputting of random numbers we simply inputted ten numbers and wrote a simple method to output the contents of the array. As the output of array was random after each of the five rounds of testing it was decided that the readStart() method was a success. The method also functioned when a non numeric key was pressed (e.g. A, B, C or D). An output of one of the testing rounds is detailed below. <table/>A test program, printArray() was used to output the value stored in the array once values had been entered.  FORMULA  The detailed brief suggested "lighting up squares" on a four by four grid but we believed the usage of boxes was too basic. We wanted to make the user actually try and engage with the program. So by writing a random number of lines to the LCD screen we could make the user "work" and hopefully enjoy the challenge. <heading>USER INTERFACE</heading>The final aspect of the system was adding a user friendly interface we decided upon the following features all implemented to display on the terminal window: <list>A welcome message asking the user for ten numbers of inputA countdown timer, this was activated before printing lines to the screenAn end of game message that announced the winner and the scores for each player</list>The test the calculation of the winner we simply played the game. One round Keypad A would win by a score of 6-4. The next round Keypad B would win by the same score. In case of a draw the final test was to have a score of 5-5. All tests passed first time. <heading>ANALYSIS AND DISCUSSION OF SYSTEM PERFORMANCE</heading>The final solution worked well and met our specification. It allowed two players to pit themselves against each other and would reward the faster player. However, there were a handful of minor issues that arose. During the time between two rounds of a match being played the LCD screen did not completely clear instantly. We are unsure of the cause of this but it does not hamper gameplay in any way so we did not actively seek to change it. When inputting the ten random numbers before the match began, for the system to work, there had to be a slight delay between the pressings of the ten numbers. This was only a fraction of a second, approximately 0.4 seconds this was due to the delay procedure necessary to stop the same number being read in ten times in quick succession. Loading time into the SWET box was quite long mainly owing to the number of print statements used. It took approximately twenty seconds for loading to complete. Finally, when trying to play two matches one after the other the scores for each player carried over from the previous round. This ability to play multiple matches was an extension of our original specification. Due to time constraints it wasn't possible to fix this issue but we believe the solution lays in the fact that the scores were stored in global variables and these were not reset at the correct time i.e. the commencement of a new match. <heading>EXTENSIONS</heading>A possible extension would be to have timer on the loop so if nothing was pressed within a certain time limit nether player would win, this would be tricky to implement if based on time as the library function is unavailable. However by trial and error a count system could be included in the reading functions. Another improvement could be to include switching each round between checking Keypad A or Keypad B first. The slight discrepancy between the readings of each keypad could be further reduced; however this is only an issue if player A presses on the correct key before the round begins. Instead of simple horizontal lines to count other shapes and images could be generated. This would be an epic task as the pixels are all individually controlled, but would be rewarding as it could then be used in simple entertainment systems for children <heading>PRACTICAL USES</heading>There are limited uses for these types of reaction games but they exist nonetheless, one such application as mentioned before is as a simple counting game for children of primary school age, it has been proven that visual stimulation is important for the development of the children's' intelligence and this would be a good way of doing so. A second option is as part of the "shocking games" section of the market. This is targeted at a mature audience as a novelty toy whereby the slowest reacting person gets a mild electric shock; there is a simpler version of this currently available from a number of shops including the menswear store Burtons. Hence the potential for sales exists. <heading>CONCLUSIONS</heading>The project has shown that high end graphics and intricate rules aren't a necessity when it comes to developing an enjoyable and stimulating game. The project has been a great success, in nine hours a working system has been produced in an unfamiliar language, integrating hardware that had not been used by the team before. Furthermore by distancing ourselves from the traditional square lighting approach to solving this problem we feel we have taken the project to another more enjoyable level. Similarly the system fulfils the specification and the competitive element is exciting for the user. 