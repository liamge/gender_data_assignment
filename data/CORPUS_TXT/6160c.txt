<heading>1. Introductionand informal statement of requirements</heading>In this coursework the problem to be solved is based on the analogy of a rat navigating a maze, trying to get from the entrance to the exit. Essentially, the aim is to develop a solution to the maze- i.e. find the path from the entrance to exit: <figure/>A LIFO stack can be used to store the path taken. It will model the movements of the rat and allow retracing of steps in the case that a wall or "dead end" is encountered. On the assignment handout sheets, the maze is depicted in a form such that it appears that grid references are given in (Y, X) form rather than the conventional (X, Y). Also, the grid references are zero-based, i.e. the first cell is (0,0). Both these features indicate that the maze should be modelled using a two-dimensional array (as in C programming) because such an array has exactly the same properties. <heading>Assumptions</heading>For any model, assumptions must be made. The assumptions provided on the Exercise sheet shall be used: Mazes consist of walls and paths. Walls cannot be crossed and it is unknown what is on the other side. Movement is possible in four directions- North (N), South (S), East (E), West (W). At a junction, N,S,E,W directions are tried in that order. The entry and exit co-ordinates are given. Other I make a further assumption and assume a Peek() function is available to read the last pushed value without removing it from the stack. It is assumed that functions/methods for finding the number of elements in an array and the sum of an array are already defined. <heading>Requirements :</heading>The algorithm must solve the maze and the solution should involve the Pop(), Push() and IsEmpty() operations. When this is achieved, the algorithm is complete and should terminate. Ideally, the algorithm should avoid revisiting squares unless a dead end has been encountered and it is attempting to find a valid path. When a dead end is encountered, Pop() should be used until it arrives back at a position that offers an alternate path. <heading>2. The Algorithm</heading><heading>Initial conditions:</heading>The two-dimensional input array M models the maze. "Wall" elements will be assigned the value of 1, while "Path" elements have the value zero: <figure/>The LIFO stack P will store the path, it is initially empty. Positions are stored in the form (I,J, dir). Where [I][J] is the array reference of the current element that the algorithm has arrived at. The LIFO stack D to store possible directions is initially empty.. The variable DSize will be used to store the number of elements in stack D dir will be initialised to 0. During run-time, it will take one of four values 1,2,3,4- corresponding to the 4 possible directions North, South, East and West. The Entry co-ordinate is A(I A,J A) and the Exit co-ordinate is B(I B,J B). <heading>2a. Expressed informally as a sequence of steps</heading>The following is designed as a general solution to work for any maze. However, the more complex the maze is, the longer the running time. <list>1) First there must be a LOOK function to obtain information about the spaces to the North, South, East and West so that the algorithm can determine which direction to move to. It also ensures that the algorithm will never try to go through walls/obstacles. The LOOK takes Peek(P) as input and returns a stack D indicating which directions are valid moves (i.e. moves which do not mean trying to move through a wall) and the number of possible valid moves (the variable DSize).Given that it has been specified that movements at junctions must be tried in the order N,S,E,W, these directions are "Looked" in reverse order so that when stack D is Popped, the directions are tried in the order specified on the exercise sheet.2) The algorithm runs until the exit co-ordinate is reached- i.e. until Peek(P) == B. The algorithm begins at the entry co-ordinates, which is Pushed into stack P.3) Use LOOK with Peek(P) as input. 4a) If there is only one valid move, that move is made. Or if there is more than one possible direction then the algorithm is on a junction. The first available move is made based on the order NSEW by Pop(D). Then, depending on direction, the appropriate position is Pushed into P and algorithm moves into that direction. The array element representing the cell that the algorithm is leaving is marked by changing its value from 0 to 1. This results in it being impassable so that the algorithm will not revisit it.4b) If there are no possible moves, Pop(P) and Look(Peek(P)) until DSize > 1.6) Repeat steps 3-5.7) When Peek(P) == B, the sum of array M is equal to the number of elements because every one of its elements will equal 1.8) Output Stack P and terminate algorithm.</list><heading>2b. Expressed as Pseudocode</heading>In this section I make comments in italics. Here I refer to the I or J parts of the co-ordinates in the form A.I  and A.J, like this: Peek(P).I and Peek(P).J, where A  is the co-ordinate. Assume the starting values:  FORMULA  In an actual program, the co-ordinates would probably be represented by a pair of linked-lists. LOOK function defined to provide information about surroundings:  FORMULA  For easier reading I will refer to the lengthy LOOK function calls as follows:  FORMULA  Each cycle of while loop updates stack so that top of the stack shows the co-ordinates and direction of next square. Pseudocode program begins here:  FORMULA  End of Algorithm Pseudocode program ends.  <heading>3. Algorithm Properties:</heading><list>Input: The array M containing the maze to be navigated, the entry co-ordinate and the exit co-ordinate.Output: A LIFO stack containing the solution to the maze or an error message.Definiteness: Each step is precisely defined using only assignment, conditionals and loop statements. Finiteness: If the maze has a solution then the algorithm terminates when this solution is found, i.e. the exit co-ordinate is reached. If there is no solution, it will terminate once the entire maze has been processed. Therefore the algorithm has a finite number of steps.Effectiveness: Each step of the algorithm is either a comparison or an assignment operation so will take a finite amount of time.Correctness: Yes, providing the maze is solvable, algorithm outputs a stack containing the solution to the maze. If the maze is not solvable, an error message is output instead.</list><heading>4. Trace</heading><heading>For the example given:</heading>The starting square is given by the position (3,0,0). The following is a trace of the "state" space of the algorithm showing all the positions that are recorded in the LIFO from start to finish. Reminder, the third figures mean as follows: 1=North, 2=South, 3=East, 4=West. Note that for my own maze in particular, the table is a complete transcript of the actual route taken. The P stack that the program produces will be more concise and will not have repeated co-ordinates. <figure/><heading>5. The Space Required</heading><heading>Calculation of the space required</heading><list><heading>For the maze:</heading>For a maze X columns by Y rows, there is a border of padding cells around it which will be filled with 1s.For an array to store such a maze, it must be able to store (total height * total width) number of elements.The total height of each column is Y + 2 padding cells.The total width of each row is X + 2 padding cells.Therefore the total number of elements required is (Y+2)(X+2).So for example, the maze I have created requires (10+2)(5+2) = 84 elements.</list><list><heading>For the stacks:</heading>The main stack P which stores the path as it is being found. The stack must have enough space to accommodate all possible routes.Movement is permitted in four directions and the maze itself (excluding borders) is X*Y.Therefore, to ensure sufficient storage space, the stack should be able to accommodate X*Y*4 positions.So for my maze, this equates to 200 spaces.</list>