<heading>How does the program work ? </heading>The program works like it's explain in the coursework 3. However, some modifications have been added. The main idea is that, one (or more) server is running one (or more) distant machine and a client which will manage the synchronisation is running on the local machine (the machine where the user is). The program contains a client side and one (or more) server side. However, the code is in the same file: dirsync.c. So, when we want to launch a server (or daemon) on a machine, we have to add an option in the command line which is called '- d' which means 'daemon'. Thus the daemon is running and waits for request from a client. When we want to launch a client, we have to precise if the source and/or the destination directories are distant. This is done with the option in the command line '-w'. Four cases are available:  FORMULA  More details about '-w' option are in the coursework 3 documentation. If the user specifies another case with the option  - w, he's informed and the program stops. If the option  - d is specified, then no other option can be added because it's the daemon. The default port number is 1985 for the daemon. The communication between the client and the server(s) are done with socket. When the client (the one who manage the synchronisation) needs information about a directory which is distant, it sends a request to the daemon which is running on this distant machine this information. This request can be something like "send me this information" or like "do that please". So, a list of request is defined. These requests (instruction) can be,  FORMULA  Every instruction has to contain 16 characters exactly (16 is defines by the constant INSTRUCTION_SIZE). This is I order to simplify the sending with socket. So, when an instruction contains less than 16 characters, the char '_' is added at the end. For example, "openfiledest" is "openfiledest____". The daemon knows what to do according to which instruction is received. Indeed, each case is treated in the dirSyncDaemon() function. When an instruction is received, the daemon and the client know and follow the same protocol. For example, if the instruction "mkdirectory" is received, this protocol is followed: The client: sends the size of the path name, then send the path name The daemon: receives the size of the path name, then receive the path name, afterward the daemon create the directory. So, each time the client needs information (or want the server to do something), an instruction is sent and is treated by the server like above. So, we have to launch this command in this case: the source is distant (on the 10.10.10.16 machine), the destination is local: <list>On the 10.10.10.16 machine: ./dirsync - dOn the local machine: ./dirsync - w s 10.10.10.16:1985:dirSource dirDest</list><heading>How the modification code has been incorporated in the original code:</heading>First of all, I had to understand exactly how the original program works, how the files are copied, how the file list is created etc... After that, at the beginning of the modification, I have added the code which treat the option '-w' and '-d'. Then, I followed each instruction contained in the synchronisation process and modify it in order to treat the case where a machine (source and/or destination) is distant. Each time modified a step in the process; this modification contains a message sending to a daemon. So, I treated the modification in the client side (message sending) and in the server/daemon side (how treat this instruction). Every time I need to communicate with a daemon, I have to send an instruction. So, I wrote a function called SendInstruction() which will send an instruction to a daemon. Here is an example which shows the general case for an instruction sending and the protocol which follows,  FORMULA  Where SendInstruction is defined like this, void SendInstruction(srcDestType* Where,char* Instruction); Above is a general example. The same architecture is used every time with some difference in order to adapt each case. <heading>Explanation of main system calls used:</heading>- The system call send is used to send a buffer buf which the size is len via the socket s. This function is defined below,  FORMULA  - The system call recv is used to receive a buffer buf which the size is len on the socket s. This function is defined below,  FORMULA  - The system call utime is used to change the modification date of a file. This is used to change the date of a new file created in the destination directory in order to have exactly the same properties than the source file. This function is defined below,  FORMULA  - The system call  chmod is used to change the mode of a file/directory (path). The new mode is defined by mod. This function is defined below,  FORMULA  - The system call  unlink is used to remove (unlink) a file/directory (path). This function is defined below,  FORMULA  - The system call  listen is used to listen for an eventual connection on the socket s. This function is defined below,  FORMULA  - The system call accept is used to accept a connection on the socket s. This is used by the daemon. This function is defined below,  FORMULA  - The system call  stat is used to obtain the stat of a file/directory (path). This function is defined below,  FORMULA  - The system call readdir is used to read the first file in a directory. This function returns this file structured by the  dirent structure. This function is defined below,  FORMULA  - The system call  closedir is used to close the directory dirp defines by the DIR structure. This function is defined below,  FORMULA  - The system call rmdir is used to remove the directory pathname. This function is defined below,  FORMULA  - The system call mkdir is used to create a directory which is called pathname. This function is defined below,  FORMULA  <heading>Print out of the compilation:</heading> FORMULA  We can see above that the compilation contains no error. As I have already specified in the design of the coursework 3, in order to compile it, we have to add the constant definition called __LINUX__. So the following line has been added at the beginning,  FORMULA  <heading>Print out of the program execution:</heading>In order to show some execution example, I have created two directories called directoryTestSource and directoryTestDestination which contain some test files and directories in order to test the program. Here is shown the content of these directories (initial content) including the content of the sub-directories, where "ll" an alias of "ls - l",  FORMULA  More clearly, the schema below shown the directories content, <figure/>Above are the initial directories contents. After the execution of dirSync, we want to have exactly the same content (from source to destination). So, the following tests execute dirSync in several case: first of all, the case where directoryTestSource and directoryTestDestination are both local (we don't specify the  - w option), then the case where directoryTestSource is distant, afterward the case where directoryTestDestination is distant. These tests have been executed on a simple machine (because when I have recorded the execution test, I didn't have an access on a network), but the obtained results are exactly the same on two different machine. So, the distant address used here is 127.0.0.1 and the port number (the default port number) is 1985. However, the same execution on two different physical machines would be demonstrated during the demonstration time, on Monday 5 th. The difference will be the machine address. Instead of using the address 127.0.0.1, the real address machine will be use. So, three tests follow. In each case, we show the execution print out, then the content of the directories after execution, in order to check that the content of the destination directory (it has to be the same than the source directory), Case where the source and the destination directories are in the local machine. In this test, no dirSync daemon have to be running (because we are in local),  FORMULA  We can see above the content of the destination directory is exactly the same than the source directory. Unnecessary files have been deleted and necessary files have been copied. Case where the source is distant (on 127.0.0.1 machine). So, a daemon has to be running on this machine. As it's explains above, if we use 2 different machine, it's exactly the same thing; a daemon has to be running on the distant machine. We use 127.0.0.1 but the effect is the same, we need to use the socket as well,  FORMULA  We can see in this example that the destination directory is the same. The execution time was a bit longer than the first case because we needed to use the socket and the file was sent through the network (not really here because 127.0.0.1 but in a real network, it's the same. 127.0.0.1 is a simulation). Case where the destination is distant. Like in the previous example, a daemon has to be running on the distant machine (here 127.0.0.1 again),  FORMULA  We can see above that the destination directory is he same than the source directory. A last case is possible, but not shown here (it would be executed during the demonstration on Monday). This case is where the source and the destination are both distant. <heading>Discussion about the program:</heading><heading>State of the program:</heading>The program works in every case (4 different cases ('s', 'd', 'l', 'sd')). The synchronisation is done correctly. In order to use it in several machine, we only need one file, dirSync and we have to specify the option '-d' if we want to launch the dirSync daemon. When we launch the daemon, it's better to use '&' to put the process in the background. <heading>Problem met:</heading>I have met a problem concerning the buffer size. Indeed, the buffer size which is actually used is very small (512*2 Byte = 1Kb). The buffer size is used when a file has to be copied from the source to the destination. This file is read and written in several steps; buffer_size bytes are read/written every step. So more the buffer size is small, more the number of steps needed to copy the file is big. And so, we need more time to copy a file. When the program works in local (127.0.0.1), the socket allows a big buffer size. However, when the destination and the source are in two different machines, the buffer size is the source of a problem which I didn't manage to solve. So I have set the buffer size to 512*2, so the program works but is a bit long when a file is big. <heading>Discussion about the problem:</heading>This coursework contains two different parts. First of all, a main part is to understand how a program works. This part requires an analyse because the program is written by another person and sometimes doesn't contain comments. So, now, I understand why to comment a code is very useful and important especially when the program is open source (hence a lot a people may read the code). The second main part is to find and write a solution to do the modification. First of all, I had to think about the architecture of the modification. After that, I could write the modification and test it on every step. 