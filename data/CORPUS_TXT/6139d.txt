<heading>NP-Complete problems:</heading>When looking at the mentioned travelling sales person's problem, we see there are obviously an infinite amount of possibilities for the journey. As we do not discriminate on the starting point and know that they must always end at their start position (make a circuit) we can figure out the number of possible permutations on the journey. Using general logic we can see that there must be n! (n*(n-1)*(n-2)*...*(2)*(1)) number of permutations available. This is because if you have n cities you have n choices for the first city (and subsequent end city), then (n-1) choices for the second city and so on until you only have 1 choice for the second to last city (as we already know the last city must be the same as the first). Using this as a guide there must be 120 (5!) possible journeys available to the TSP. This is obviously too many to do simply by pen and paper and would probably be a waste of time actually working them all out by hand, as we could probably see the most efficient way of traversing the circuit by drawing a rough diagram (see appendix 1). By just simply using this diagram and by finding the shortest path from one node to another or maybe a slightly longer path but which includes visiting another node on the way, e.g. it is shorter to go straight from London to Cambridge than that via Stansted, however by going via Stansted it means we can then continue straight on from Cambridge, I have found what I believe to be the shortest path without the lengthy use of finding the length of every circuit possible to be: <figure/>This circuit works out to be 237 miles. We can obviously not guarantee that this is definitely the shortest path as I have not worked out every possible circuit however within the limits I have this would be my most accurate idea of what the shortest circuit could be. When we talk about a NP Problem where n=30 the number of permutations would be 2.65*10 32 (265000000000000000000000000000000), as using the example given that it takes 1 nanosecond (1*10 -9 seconds) to find each circuit on a Dell Pentium PC it would take 4.42*10 21 seconds or 8.41*10 15 years. To verify this very loge number I found out how many processes would happen every year, by doing the following: First finding out how many nanoseconds there are in a year:  FORMULA  Then we know there are 3600 seconds in an hour and 24 hours in a day. Therefore there are 8.64*10 12 nanoseconds per day. Using 365 days a year there is 3.15*10 16 nanoseconds in a year, and this would be the same amount of processes a year. 30! (number of processes needed)/ 3.15*10 16 (processes per year) would give the number of years needed to complete these processes. This gives an amazing 8.41*10 15 years to compute just the array of permutations of the above problem. This is obviously at present an unreachable goal. Something that seems so simple increases so rapidly as the n is increased. From my understanding an NP Complete problem is loosely speaking, a class of problems that are believed unsolvable within a reasonable amount of time in the worst case. Thus, approximation algorithms are very important for solving real-world problems such as the payphone coin collector problem?? There are other methods of finding the shortest possible circuits that would cut the amount of time, such as algorithms which rearrange the nodes and distances to find a path which is the shortest without computing every possible circuit. These algorithm works in a similar way to how a human works out their best guess of the shortest circuit. They are designed to notice which distances are very large and work out a way to go around them or avoid them. They also work out how to get from one place to another whether it is sometime more beneficial to go a little further but to go via another node. From Wikipedia.org the following are given as shortest path algorithms: The most important algorithms for solving this problem are: <list>Dijkstra's algorithm - solves single source problem if all edge weights are greater than or equal to zero. Without worsening the run time, this algorithm can in fact compute the shortest paths from a given start point s to all other nodes. Bellman-Ford algorithm - solves single source problem if edge weights may be negative. A* search algorithm solves for single source shortest paths using heuristics to try to speed up the search Floyd-Warshall algorithm - solves all pairs shortest paths. Johnson's algorithm - solves all pairs shortest paths, may be faster than Floyd-Warshall on sparse graphs. Perturbation theory; finds (at worst) the locally shortest path</list><heading>Halting Problem:</heading><heading>Pseudo Code given as a general overview of what our program had to do:</heading> FORMULA  My code of the above translated into a 'C' program:  FORMULA   FORMULA  <heading>Input: Output</heading><table/>From the above inputs we can see that the program always halts and never runs infintely. However from the above inputs it is not possible to say that the program will always stop, there will always be a number 1 bigger that the number you have tried that we can not sya for sure will work. As we can see the number 27 has a lot of printed output before it stops, if we looked at the pattern of number of terms in the output, for the number 21 there are 7 outputs for 25 there are 23 and for 27 there are over 110 outputs. This means it looks like the number of outputs is at least tripling when the input is increased by 2 or 4, so it is fair to predict that an input of 29 or 31 would produce over 330 outputs. With this extreme increase of outputs per small increase in input it is fair to say that the number of outputs would eventually become extremely large. The importance of the Halting Problem is that it was one of the first prolblems to be proved undecideable, with our instance of the above halting problems, it is fair to say that we can never guarantee that a random number that is inputted will always halt. 