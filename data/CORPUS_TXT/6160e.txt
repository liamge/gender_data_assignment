<heading>NP-Complete problems </heading><heading>General Procedure:</heading><table/><figure/>In solving of TSPs, we are essentially finding Hamiltonian Circuits - i.e. finding that path that that will visit each vertex (for this exercise, these happen to be cities) and then return to the point of origin. For solving TSPs, there is the additional condition that we are seeking the circuit with the minimum possible weight (i.e. shortest distance travelled): Start from a city and proceed to the nearest city that has not yet been visited. Stop when last city is reached and return to the starting city. Repeat with a different starting city and compare total weights to find to find the minimum possible weight. Here are the distances of some of the various possible circuits: <table/><heading>Use of Permutations and Verification of Result</heading>The number of possible circuits is equivalent to the number of possible permutations. From initial testing, the shortest circuit has a distance of 237 and there are multiple possible circuits which result in this total distance. For the example problem, there are 5! = 120 possible circuits, where half of these are the other half in reverse. The 120 combinations consist of 24 circuits for each starting city (12 circuits and their reverses). The value of 120 was obtained via application of the permutation formula:  FORMULA  where n is the total number of items and r is the number of items required in each set. Since n = r in this exercise (permutations of 5 cities from a set of 5 cities), the denominator is 0! = 1. So the formula is reduced to n! . 120 permutations is a small enough number to "brute force" and hence verify whether or not the shortest circuit has indeed been found. An Excel spreadsheet and lookup functions were used for this. First, a list of permutations need to be found, this was done using the Permutation Generator at  URL  This was put onto the spreadsheet. The table giving relative distances was pasted into the spreadsheet to use as a lookup table. With the help of the INDEX spreadsheet function, this allowed the distances travelled to be generated using the list of permutations. The INDEX spreadsheet function is as follows: INDEX(reference,row_num,column_num). The function will use pairs of two consecutive numbers in the permutations to select the appropriate distance value from the lookup table. A sample of the data generated is shown here: <table/>Data for all 120 permutations (circuits) were generated and the shortest possible distance is confirmed to be 237. There are 10 circuits that will result in the total distance of 237- this consists of 5 circuits and their reverse paths. For brevity, only one direction will be shown- their reverse paths are equally valid: <table/><heading>Questions</heading><heading>If no. of cities = 30 and if it takes 1 nanosecond (10-9 seconds) to find one circuit (i.e. Start to finish and back to start) on a Dell Pentium PC, how long would it take to find the shortest circuit? </heading> FORMULA  <heading>Is exhaustive search of all possible paths the only way to solve the problem? </heading>Reference:  URL  There is not yet a general solution for the problem but using "heuristic algorithms" it is possible to obtain a "best guess" solution which is usually sufficient. For small finite number of cities, exact solutions can be obtained using "branch and bound" algorithms and "linear programming". <heading>What are NP-Complete problems and why TSP is an NP-Complete problem? </heading>NP-Complete problems are problems which cannot be easily solved by computation. TSP is NP-Complete because it the time taken to solve it increases exponentially as the complexity of the problem increases- i.e. the time taken increases exponentially as the number of cities increases. <heading>Halting Problem</heading>Translate the following pseudo-code into a 'C' program and test the program by executing it for the following inputs: n = 3, 21, 25, 27. Check if there is an input for which the program doesn't halt.  FORMULA  Output values for each of the inputs for the above program:  FORMULA  The problem with this particular implementation is that it does not check validity of input and so does NOT halt when input other than integers are used. As long as input is an INTEGER, the program will halt. <heading>Significance of "halting problem". </heading>The halting problem, as it exists in computability theory, is deciding whether a program will finish or continue running forever, given a particular input. To solve the halting problem is to develop a general solution for determining finiteness. While this can in general be determined for programs individually, it is another matter to In 1936, Alan Turing proved that a general algorithm (one that works for any program) to solve the halting problem for all possible inputs cannot exist. 