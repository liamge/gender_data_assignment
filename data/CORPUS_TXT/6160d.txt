<heading>1. Introduction</heading>The tree data model is used in computer science for things like file systems and search algorithms. Trees are also used in modelling chemical structures and biological systems. This coursework will investigate tree models as applied to binary search and also look at the procedure for inserting data into such a tree. This coursework will result in a better understanding of how to model a problem based on the tree model. The degree of the tree that will be used is the maximum number of child nodes that any particular node can have. In this case, where a binary tree will be used, the degree is 2. An algorithm is to be devised to insert data into a binary tree and thus construct trees for the data. The following datasets will be involved: <list>List of all SSE degree courses A subset of counties in England.</list><heading>Informal statement of requirements</heading>The insertion algorithm should result in a tree containing all elements of the dataset in ascending alphanumeric order (i.e. A to Z, 0 to 9). The tree will consist of nodes such that every node other that the root node will have one parent node and either: <list>Zero child nodesOne Left child nodeOne Right child nodeBoth a Left and a Right child node.</list>There should be no repetition- i.e. all nodes in the tree must have unique values. Therefore the algorithm must check if adding the current item duplicates an existing item and discard if this is the case. The value of all nodes in the left sub-trees must be less than the value of the node it descends from. The value of all nodes in the right sub-trees must be greater than the value of the node it descends from. <heading>2. The Algorithm</heading><heading>As an Informal Series of Steps</heading>If a non-existing node is referenced, its value is automatically NULL. The algorithm will start building tree from the root node.  FORMULA  <heading>As Pseudocode</heading>The Pseudocode will be designed with the following assumptions: The data set D that the algorithm will operate on is a finite set with N elements and D[x] refers to element x of the dataset. It will be modelled as a single-dimension array. R and C are nodes. Nodes may possibly have child C nodes. There may be 0, 1 or 2 C nodes. A parent node may have either one child of either type left[R] or right[R] or have both child nodes. The type of the node will be determined by whether the value of C is less than or greater than the value of R. If less, it is a left child (left[R]) else it is a (right[R]). Empty or non-existent nodes return the value NULL when referenced The data will be stored into the tree T. <figure/>The Pseudocode for this algorithm is as follows.  FORMULA  <heading>Testing</heading>The two sample datasets that the algorithm is to run on are: <list>List of all SSE degree courses A subset of counties in England.</list>Here the algorithm will be used for each in turn. <heading>List of all SSE degree courses </heading>This is a list of SSE degree courses (copied directly from the various SSE pages, for CS, Cyb, EE, IT). For the ease of display of the tree, the algorithm shall run on the UCAS codes of the degree programmes. The convention for sorting used is numbers before letters, i.e. : 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ <table/>The resulting tree is shown on the next page. It is an unbalanced tree because the root used would not be the middle item if the elements were ordered alphabetically. In an alphabetical list, the root would be located near the end of the list, this is why the tree left-heavy. <figure/><heading>Subset of Counties in England</heading>The following shows the worst possible use of a binary tree. As the dataset is already in alphabetical order, the resulting tree is nothing more than a list and offers no additional advantages compared to a normal list. <heading>Steps to Insert an Item</heading>For the first tree (SSE degrees), the longest path from root to leaf is 11 elements including the root. Therefore for that tree, up to 11 iterations of the algorithm loop would be required to insert a new item. The inefficiency of the second tree (subset of English counties) is demonstrated by the fact that despite being built from a smaller dataset (18 counties versus 24 SSE degrees), it would take up to 18 iterations to insert a new item. <heading>3. Algorithm Properties:</heading><list>Input: The dataset containing the data that is to be inserted into a binary tree.Output: The binary search tree T. Definiteness: The algorithm exhibits definiteness in that all data that will be inserted into the tree will one and only one of the following: be equal to the top node, greater than the top node or less than the top node. Comparison statements identify which of these is the case for each data item to be inserted so that it can be insert to the correct location by an assignment statement. A loop ensures that every data item is dealt with. Finiteness: The algorithm terminates when all data has been inserted.Effectiveness: Each step of the algorithm is either a comparison or an assignment operation so will take a finite amount of time.Corrrectness: Yes, algorithm results in a binary search tree of the data.</list>